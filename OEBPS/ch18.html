<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 18. Controlling the Keyboard and Mouse with GUI Automation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 18. Controlling the Keyboard and Mouse with GUI Automation"><div class="titlepage"><div><div><h1 class="title"><a id="controlling_the_keyboard_and_mouse_with"/>Chapter 18. Controlling the Keyboard and Mouse with GUI Automation</h1></div></div></div><p><a id="iddle1642" class="indexterm"/>Knowing various Python modules for editing spreadsheets, downloading files, and launching programs is useful, but sometimes there just aren’t any modules for the applications you need to work with. The ultimate tools for automating tasks on your computer are programs you write that directly control the keyboard and mouse. These programs can control other applications by sending them virtual keystrokes and mouse clicks, just as if you were sitting at your computer and interacting with the applications yourself. This technique is known as <span class="emphasis"><em>graphical user interface automation</em></span>, or <span class="emphasis"><em>GUI automation</em></span> for short. With GUI automation, your programs can do anything that a human user sitting at the computer can do, except spill coffee on the keyboard.</p><p>Think of GUI automation as programming a robotic arm. You can program the robotic arm to type at your keyboard and move your mouse for you. This technique is particularly useful for tasks that involve a lot of mindless clicking or filling out of forms.</p><p><a id="iddle1640" class="indexterm"/><a id="iddle1641" class="indexterm"/><a id="iddle1644" class="indexterm"/><a id="iddle1733" class="indexterm"/><a id="iddle1821" class="indexterm"/><a id="iddle1872" class="indexterm"/><a id="iddle2041" class="indexterm"/><a id="iddle2222" class="indexterm"/><a id="iddle2227" class="indexterm"/><a id="iddle2695" class="indexterm"/>The <code class="literal">pyautogui</code> module has functions for simulating mouse movements, button clicks, and scrolling the mouse wheel. This chapter covers only a subset of PyAutoGUI’s features; you can find the full documentation at <span class="emphasis"><em><a class="ulink" href="http://pyautogui.readthedocs.org/">http://pyautogui.readthedocs.org/</a></em></span>.</p><div class="sect1" title="Installing the pyautogui Module"><div class="titlepage"><div><div><h1 class="title"><a id="installing_the_pyautogui_module"/>Installing the pyautogui Module</h1></div></div></div><p>The <code class="literal">pyautogui</code> module can send virtual keypresses and mouse clicks to Windows, OS X, and Linux. Depending on which operating system you’re using, you may have to install some other modules (called <span class="emphasis"><em>dependencies</em></span>) before you can install PyAutoGUI.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On Windows, there are no other modules to install.</p></li><li class="listitem"><p>On OS X, run <span class="strong"><strong><code class="literal">sudo pip3 install pyobjc-framework-Quartz</code></strong></span>, <span class="strong"><strong><code class="literal">sudo pip3 install pyobjc-core</code></strong></span>, and then <span class="strong"><strong><code class="literal">sudo pip3 install pyobjc</code></strong></span>.</p></li><li class="listitem"><p>On Linux, run <span class="strong"><strong><code class="literal">sudo pip3 install python3-xlib</code></strong></span>, <span class="strong"><strong><code class="literal">sudo apt-get install scrot</code></strong></span>, <span class="strong"><strong><code class="literal">sudo apt-get install python3-tk</code></strong></span>, and <span class="strong"><strong><code class="literal">sudo apt-get install python3-dev</code></strong></span>. (Scrot is a screenshot program that PyAutoGUI uses.)</p></li></ul></div><p>After these dependencies are installed, run <span class="strong"><strong><code class="literal">pip install pyautogui</code></strong></span> (or <span class="strong"><strong><code class="literal">pip3</code></strong></span> on OS X and Linux) to install PyAutoGUI.</p><p>Appendix A has complete information on installing third-party modules. To test whether PyAutoGUI has been installed correctly, run <span class="strong"><strong><code class="literal">import pyautogui</code></strong></span> from the interactive shell and check for any error messages.</p></div><div class="sect1" title="Staying on Track"><div class="titlepage"><div><div><h1 class="title"><a id="staying_on_track"/>Staying on Track</h1></div></div></div><p>Before you jump in to a GUI automation, you should know how to escape problems that may arise. Python can move your mouse and type keystrokes at an incredible speed. In fact, it might be too fast for other programs to keep up with. Also, if something goes wrong but your program keeps moving the mouse around, it will be hard to tell what exactly the program is doing or how to recover from the problem. Like the enchanted brooms from Disney’s <span class="emphasis"><em>The Sorcerer’s Apprentice</em></span>, which kept filling—and then overfilling—Mickey’s tub with water, your program could get out of control even though it’s following your instructions perfectly. Stopping the program can be difficult if the mouse is moving around on its own, preventing you from clicking the IDLE window to close it. Fortunately, there are several ways to prevent or recover from GUI automation problems.</p><div class="sect2" title="Shutting Down Everything by Logging Out"><div class="titlepage"><div><div><h2 class="title"><a id="shutting_down_everything_by_logging_out"/>Shutting Down Everything by Logging Out</h2></div></div></div><p>Perhaps the simplest way to stop an out-of-control GUI automation program is to log out, which will shut down all running programs. On Windows and Linux, the logout hotkey is <span class="smaller">CTRL</span>-<span class="smaller">ALT</span>-<span class="smaller">DEL</span>. On OS X, it is <span class="inlinemediaobject"><a id="inline_id00003"/><img src="figs/web/common-01.png.jpg" alt=""/></span>-<span class="smaller">SHIFT</span>-<span class="smaller">OPTION</span>-Q. By logging out, you’ll lose any unsaved work, but at least you won’t have to wait for a full reboot of the computer.</p></div><div class="sect2" title="Pauses and Fail-Safes"><div class="titlepage"><div><div><h2 class="title"><a id="pauses_and_fail-safes"/>Pauses and Fail-Safes</h2></div></div></div><p><a id="iddle1208" class="indexterm"/><a id="iddle1217" class="indexterm"/><a id="iddle1633" class="indexterm"/><a id="iddle1950" class="indexterm"/><a id="iddle2082" class="indexterm"/><a id="iddle2206" class="indexterm"/><a id="iddle2217" class="indexterm"/><a id="iddle2223" class="indexterm"/><a id="iddle2228" class="indexterm"/><a id="iddle2234" class="indexterm"/>You can tell your script to wait after every function call, giving you a short window to take control of the mouse and keyboard if something goes wrong. To do this, set the <code class="literal">pyautogui.PAUSE</code> variable to the number of seconds you want it to pause. For example, after setting <code class="literal">pyautogui.PAUSE = 1.5</code>, every PyAutoGUI function call will wait one and a half seconds after performing its action. Non-PyAutoGUI instructions will not have this pause.</p><p>PyAutoGUI also has a fail-safe feature. Moving the mouse cursor to the upper-left corner of the screen will cause PyAutoGUI to raise the <code class="literal">pyautogui.FailSafeException</code> exception. Your program can either handle this exception with <code class="literal">try</code> and <code class="literal">except</code> statements or let the exception crash your program. Either way, the fail-safe feature will stop the program if you quickly move the mouse as far up and left as you can. You can disable this feature by setting <code class="literal">pyautogui.FAILSAFE = False</code>. Enter the following into the interactive shell:</p><a id="pro_id00625"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import pyautogui</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.PAUSE = 1</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.FAILSAFE = True</strong></span></pre><p>Here we import <code class="literal">pyautogui</code> and set <code class="literal">pyautogui.PAUSE</code> to <code class="literal">1</code> for a one-second pause after each function call. We set <code class="literal">pyautogui.FAILSAFE</code> to <code class="literal">True</code> to enable the fail-safe feature.</p></div></div><div class="sect1" title="Controlling Mouse Movement"><div class="titlepage"><div><div><h1 class="title"><a id="controlling_mouse_movement"/>Controlling Mouse Movement</h1></div></div></div><p>In this section, you’ll learn how to move the mouse and track its position on the screen using PyAutoGUI, but first you need to understand how PyAutoGUI works with coordinates.</p><p>The mouse functions of PyAutoGUI use x- and y-coordinates. <a class="xref" href="ch18.html#coordinates_of_a_computer_screen_with_19" title="Figure 18-1. The coordinates of a computer screen with 1920×1080 resolution">Figure 18-1</a> shows the coordinate system for the computer screen; it’s similar to the coordinate system used for images, discussed in <a class="xref" href="ch17.html" title="Chapter 17. Manipulating Images">Chapter 17</a>. The <span class="emphasis"><em>origin</em></span>, where <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are both zero, is at the upper-left corner of the screen. The x-coordinates increase going to the right, and the y-coordinates increase going down. All coordinates are positive integers; there are no negative coordinates.</p><div class="figure"><a id="coordinates_of_a_computer_screen_with_19"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00097"/><img src="figs/web/18fig01.png.jpg" alt="The coordinates of a computer screen with 1920×1080 resolution"/></div></div><p class="title">Figure 18-1. The coordinates of a computer screen with 1920×1080 resolution</p></div><p><a id="iddle1209" class="indexterm"/><a id="iddle1373" class="indexterm"/><a id="iddle1968" class="indexterm"/><a id="iddle1972" class="indexterm"/><a id="iddle2231" class="indexterm"/><a id="iddle2233" class="indexterm"/><a id="iddle2239" class="indexterm"/><a id="iddle2343" class="indexterm"/><a id="iddle2434" class="indexterm"/>Your <span class="emphasis"><em>resolution</em></span> is how many pixels wide and tall your screen is. If your screen’s resolution is set to 1920×1080, then the coordinate for the upper-left corner will be (0, 0), and the coordinate for the bottom-right corner will be (1919, 1079).</p><p>The <code class="literal">pyautogui.size()</code> function returns a two-integer tuple of the screen’s width and height in pixels. Enter the following into the interactive shell:</p><a id="pro_id00626"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import pyautogui</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.size()</strong></span>
(1920, 1080)
&gt;&gt;&gt; <span class="strong"><strong>width, height = pyautogui.size()</strong></span></pre><p><code class="literal">pyautogui.size()</code> returns <code class="literal">(1920, 1080)</code> on a computer with a 1920×1080 resolution; depending on your screen’s resolution, your return value may be different. You can store the width and height from <code class="literal">pyautogui.size()</code> in variables like <code class="literal">width</code> and <code class="literal">height</code> for better readability in your programs.</p><div class="sect2" title="Moving the Mouse"><div class="titlepage"><div><div><h2 class="title"><a id="moving_the_mouse"/>Moving the Mouse</h2></div></div></div><p>Now that you understand screen coordinates, let’s move the mouse. The <code class="literal">pyautogui.moveTo()</code> function will instantly move the mouse cursor to a specified position on the screen. Integer values for the x- and y-coordinates make up the function’s first and second arguments, respectively. An optional <code class="literal">duration</code> integer or float keyword argument specifies the number of seconds it should take to move the mouse to the destination. If you leave it out, the default is <code class="literal">0</code> for instantaneous movement. (All of the <code class="literal">duration</code> keyword arguments in PyAutoGUI functions are optional.) Enter the following into the interactive shell:</p><a id="pro_id00627"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import pyautogui</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>for i in range(10):</strong></span>
      <span class="strong"><strong>pyautogui.moveTo(100, 100, duration=0.25)</strong></span>
      <span class="strong"><strong>pyautogui.moveTo(200, 100, duration=0.25)</strong></span>
      <span class="strong"><strong>pyautogui.moveTo(200, 200, duration=0.25)</strong></span>
      <span class="strong"><strong>pyautogui.moveTo(100, 200, duration=0.25)</strong></span></pre><p>This example moves the mouse cursor clockwise in a square pattern among the four coordinates provided a total of ten times. Each movement takes a quarter of a second, as specified by the <code class="literal">duration=0.25</code> keyword argument. If you hadn’t passed a third argument to any of the <code class="literal">pyautogui.moveTo()</code> calls, the mouse cursor would have instantly teleported from point to point.</p><p>The <code class="literal">pyautogui.moveRel()</code> function moves the mouse cursor <span class="emphasis"><em>relative</em></span> to its current position. The following example moves the mouse in the same square pattern, except it begins the square from wherever the mouse happens to be on the screen when the code starts running:</p><a id="pro_id00628"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import pyautogui</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>for i in range(10):</strong></span>
      <span class="strong"><strong>pyautogui.moveRel(100, 0, duration=0.25)</strong></span>
      <span class="strong"><strong>pyautogui.moveRel(0, 100, duration=0.25)</strong></span>
      <span class="strong"><strong>pyautogui.moveRel(-100, 0, duration=0.25)</strong></span>
      <span class="strong"><strong>pyautogui.moveRel(0, -100, duration=0.25)</strong></span></pre><p><a id="iddle1638" class="indexterm"/><a id="iddle1710" class="indexterm"/><a id="iddle1781" class="indexterm"/><a id="iddle1955" class="indexterm"/><a id="iddle1956" class="indexterm"/><a id="iddle1961" class="indexterm"/><a id="iddle1969" class="indexterm"/><a id="iddle2142" class="indexterm"/><a id="iddle2200" class="indexterm"/><a id="iddle2226" class="indexterm"/><a id="iddle2232" class="indexterm"/><code class="literal">pyautogui.moveRel()</code> also takes three arguments: how many pixels to move horizontally to the right, how many pixels to move vertically downward, and (optionally) how long it should take to complete the movement. A negative integer for the first or second argument will cause the mouse to move left or upward, respectively.</p></div><div class="sect2" title="Getting the Mouse Position"><div class="titlepage"><div><div><h2 class="title"><a id="getting_the_mouse_position"/>Getting the Mouse Position</h2></div></div></div><p>You can determine the mouse’s current position by calling the <code class="literal">pyautogui.position()</code> function, which will return a tuple of the mouse cursor’s <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> positions at the time of the function call. Enter the following into the interactive shell, moving the mouse around after each call:</p><a id="pro_id00629"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>pyautogui.position()</strong></span>
(311, 622)
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.position()</strong></span>
(377, 481)
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.position()</strong></span>
(1536, 637)</pre><p>Of course, your return values will vary depending on where your mouse cursor is.</p></div></div><div class="sect1" title="Project: “Where Is the Mouse Right Now?”"><div class="titlepage"><div><div><h1 class="title"><a id="project_quotation_markwhere_is_the_mouse"/>Project: “Where Is the Mouse Right Now?”</h1></div></div></div><p>Being able to determine the mouse position is an important part of setting up your GUI automation scripts. But it’s almost impossible to figure out the exact coordinates of a pixel just by looking at the screen. It would be handy to have a program that constantly displays the x- and y-coordinates of the mouse cursor as you move it around.</p><p>At a high level, here’s what your program should do:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Display the current x- and y-coordinates of the mouse cursor.</p></li><li class="listitem"><p>Update these coordinates as the mouse moves around the screen.</p></li></ul></div><p>This means your code will need to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Call the <code class="literal">position()</code> function to fetch the current coordinates.</p></li><li class="listitem"><p>Erase the previously printed coordinates by printing <code class="literal">\b</code> backspace characters to the screen.</p></li><li class="listitem"><p>Handle the <code class="literal">KeyboardInterrupt</code> exception so the user can press <span class="smaller">CTRL</span>-C to quit.</p></li></ul></div><p>Open a new file editor window and save it as <span class="emphasis"><em>mouseNow.py</em></span>.</p><div class="sect2" title="Step 1: Import the Module"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_import_the_module"/>Step 1: Import the Module</h2></div></div></div><p><a id="iddle1724" class="indexterm"/><a id="iddle1782" class="indexterm"/><a id="iddle1957" class="indexterm"/><a id="iddle1958" class="indexterm"/><a id="iddle1959" class="indexterm"/><a id="iddle1960" class="indexterm"/><a id="iddle1965" class="indexterm"/><a id="iddle2686" class="indexterm"/><a id="iddle2687" class="indexterm"/>Start your program with the following:</p><a id="pro_id00630"/><pre class="programlisting">#! python3
# mouseNow.py - Displays the mouse cursor's current position.
import pyautogui
print('Press Ctrl-C to quit.')
#TODO: Get and print the mouse coordinates.</pre><p>The beginning of the program imports the <code class="literal">pyautogui</code> module and prints a reminder to the user that they have to press <span class="smaller">CTRL</span>-C to quit.</p></div><div class="sect2" title="Step 2: Set Up the Quit Code and Infinite Loop"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_set_up_the_quit_code_and_infinite"/>Step 2: Set Up the Quit Code and Infinite Loop</h2></div></div></div><p>You can use an infinite <code class="literal">while</code> loop to constantly print the current mouse coordinates from <code class="literal">mouse.position()</code>. As for the code that quits the program, you’ll need to catch the <code class="literal">KeyboardInterrupt</code> exception, which is raised whenever the user presses <span class="smaller">CTRL</span>-C. If you don’t handle this exception, it will display an ugly traceback and error message to the user. Add the following to your program:</p><a id="pro_id00631"/><pre class="programlisting">   #! python3
   # mouseNow.py - Displays the mouse cursor's current position.
   import pyautogui
   print('Press Ctrl-C to quit.')
   <span class="strong"><strong>try:</strong></span>
       <span class="strong"><strong>while True:</strong></span>
           <span class="strong"><strong># TODO: Get and print the mouse coordinates.</strong></span>
➊ <span class="strong"><strong>except KeyboardInterrupt:</strong></span>
➋     <span class="strong"><strong>print('\nDone.')</strong></span></pre><p>To handle the exception, enclose the infinite <code class="literal">while</code> loop in a <code class="literal">try</code> statement. When the user presses <span class="smaller">CTRL</span>-C, the program execution will move to the <code class="literal">except</code> clause ➊ and <code class="literal">Done.</code> will be printed in a new line ➋.</p></div><div class="sect2" title="Step 3: Get and Print the Mouse Coordinates"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_get_and_print_the_mouse_coordinat"/>Step 3: Get and Print the Mouse Coordinates</h2></div></div></div><p>The code inside the <code class="literal">while</code> loop should get the current mouse coordinates, format them to look nice, and print them. Add the following code to the inside of the <code class="literal">while</code> loop:</p><a id="pro_id00632"/><pre class="programlisting">#! python3
# mouseNow.py - Displays the mouse cursor's current position.
import pyautogui
print('Press Ctrl-C to quit.')
--<span class="emphasis"><em>snip</em></span>--
        <span class="strong"><strong># Get and print the mouse coordinates.</strong></span>
        <span class="strong"><strong>x, y = pyautogui.position()</strong></span>
        <span class="strong"><strong>positionStr = 'X: ' + str(x).rjust(4) + ' Y: ' + str(y).rjust(4)</strong></span>
--<span class="emphasis"><em>snip</em></span>--</pre><p><a id="iddle1104" class="indexterm"/><a id="iddle1634" class="indexterm"/><a id="iddle1951" class="indexterm"/><a id="iddle2143" class="indexterm"/><a id="iddle2218" class="indexterm"/><a id="iddle2235" class="indexterm"/><a id="iddle2352" class="indexterm"/><a id="iddle2483" class="indexterm"/>Using the multiple assignment trick, the <code class="literal">x</code> and <code class="literal">y</code> variables are given the values of the two integers returned in the tuple from <code class="literal">pyautogui.position()</code>. By passing <code class="literal">x</code> and <code class="literal">y</code> to the <code class="literal">str()</code> function, you can get string forms of the integer coordinates. The <code class="literal">rjust()</code> string method will right-justify them so that they take up the same amount of space, whether the coordinate has one, two, three, or four digits. Concatenating the right-justified string coordinates with <code class="literal">'X: '</code> and <code class="literal">' Y: '</code> labels gives us a neatly formatted string, which will be stored in <code class="literal">positionStr</code>.</p><p>At the end of your program, add the following code:</p><a id="pro_id00633"/><pre class="programlisting">   #! python3
   # mouseNow.py - Displays the mouse cursor's current position.
   --<span class="emphasis"><em>snip</em></span>--
           <span class="strong"><strong>print(positionStr, end='')</strong></span>
➊         <span class="strong"><strong>print('\b' * len(positionStr), end='', flush=True)</strong></span></pre><p>This actually prints <code class="literal">positionStr</code> to the screen. The <code class="literal">end=''</code> keyword argument to <code class="literal">print()</code> prevents the default newline character from being added to the end of the printed line. It’s possible to erase text you’ve already printed to the screen—but only for the most recent line of text. Once you print a newline character, you can’t erase anything printed before it.</p><p>To erase text, print the <code class="literal">\b</code> backspace escape character. This special character erases a character at the end of the current line on the screen. The line at ➊ uses string replication to produce a string with as many <code class="literal">\b</code> characters as the length of the string stored in <code class="literal">positionStr</code>, which has the effect of erasing the <code class="literal">positionStr</code> string that was last printed.</p><p>For a technical reason beyond the scope of this book, always pass <code class="literal">flush=True</code> to <code class="literal">print()</code> calls that print <code class="literal">\b</code> backspace characters. Otherwise, the screen might not update the text as desired.</p><p>Since the <code class="literal">while</code> loop repeats so quickly, the user won’t actually notice that you’re deleting and reprinting the whole number on the screen. For example, if the x-coordinate is 563 and the mouse moves one pixel to the right, it will look like only the 3 in 563 is changed to a 4.</p><p>When you run the program, there will be only two lines printed. They should look like something like this:</p><a id="pro_id00634"/><pre class="programlisting">Press Ctrl-C to quit.
X: 290 Y: 424</pre><p>The first line displays the instruction to press <span class="smaller">CTRL</span>-C to quit. The second line with the mouse coordinates will change as you move the mouse around the screen. Using this program, you’ll be able to figure out the mouse coordinates for your GUI automation scripts.</p></div></div><div class="sect1" title="Controlling Mouse Interaction"><div class="titlepage"><div><div><h1 class="title"><a id="controlling_mouse_interaction"/>Controlling Mouse Interaction</h1></div></div></div><p>Now that you know how to move the mouse and figure out where it is on the screen, you’re ready to start clicking, dragging, and scrolling.</p><div class="sect2" title="Clicking the Mouse"><div class="titlepage"><div><div><h2 class="title"><a id="clicking_the_mouse"/>Clicking the Mouse</h2></div></div></div><p><a id="iddle1174" class="indexterm"/><a id="iddle1177" class="indexterm"/><a id="iddle1349" class="indexterm"/><a id="iddle1358" class="indexterm"/><a id="iddle1359" class="indexterm"/><a id="iddle1362" class="indexterm"/><a id="iddle1635" class="indexterm"/><a id="iddle1636" class="indexterm"/><a id="iddle1943" class="indexterm"/><a id="iddle1952" class="indexterm"/><a id="iddle1953" class="indexterm"/><a id="iddle1963" class="indexterm"/><a id="iddle1970" class="indexterm"/><a id="iddle1973" class="indexterm"/><a id="iddle2203" class="indexterm"/><a id="iddle2204" class="indexterm"/><a id="iddle2205" class="indexterm"/><a id="iddle2210" class="indexterm"/><a id="iddle2219" class="indexterm"/><a id="iddle2220" class="indexterm"/><a id="iddle2230" class="indexterm"/><a id="iddle2237" class="indexterm"/><a id="iddle2349" class="indexterm"/>To send a virtual mouse click to your computer, call the <code class="literal">pyautogui.click()</code> method. By default, this click uses the left mouse button and takes place wherever the mouse cursor is currently located. You can pass x- and y-coordinates of the click as optional first and second arguments if you want it to take place somewhere other than the mouse’s current position.</p><p>If you want to specify which mouse button to use, include the <code class="literal">button</code> keyword argument, with a value of <code class="literal">'left'</code>, <code class="literal">'middle'</code>, or <code class="literal">'right'</code>. For example, <code class="literal">pyautogui.click(100, 150, button='left')</code> will click the left mouse button at the coordinates (100, 150), while <code class="literal">pyautogui.click(200, 250, button='right')</code> will perform a right-click at (200, 250).</p><p>Enter the following into the interactive shell:</p><a id="pro_id00635"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import pyautogui</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.click(10, 5)</strong></span></pre><p>You should see the mouse pointer move to near the top-left corner of your screen and click once. A full “click” is defined as pushing a mouse button down and then releasing it back up without moving the cursor. You can also perform a click by calling <code class="literal">pyautogui.mouseDown()</code>, which only pushes the mouse button down, and <code class="literal">pyautogui.mouseUp()</code>, which only releases the button. These functions have the same arguments as <code class="literal">click()</code>, and in fact, the <code class="literal">click()</code> function is just a convenient wrapper around these two function calls.</p><p>As a further convenience, the <code class="literal">pyautogui.doubleClick()</code> function will perform two clicks with the left mouse button, while the <code class="literal">pyautogui.rightClick()</code> and <code class="literal">pyautogui.middleClick()</code> functions will perform a click with the right and middle mouse buttons, respectively.</p></div><div class="sect2" title="Dragging the Mouse"><div class="titlepage"><div><div><h2 class="title"><a id="dragging_the_mouse"/>Dragging the Mouse</h2></div></div></div><p><span class="emphasis"><em>Dragging</em></span> means moving the mouse while holding down one of the mouse buttons. For example, you can move files between folders by dragging the folder icons, or you can move appointments around in a calendar app.</p><p>PyAutoGUI provides the <code class="literal">pyautogui.dragTo()</code> and <code class="literal">pyautogui.dragRel()</code> functions to drag the mouse cursor to a new location or a location relative to its current one. The arguments for <code class="literal">dragTo()</code> and <code class="literal">dragRel()</code> are the same as <code class="literal">moveTo()</code> and <code class="literal">moveRel()</code>: the x-coordinate/horizontal movement, the y-coordinate/vertical movement, and an optional duration of time. (OS X does not drag correctly when the mouse moves too quickly, so passing a <code class="literal">duration</code> keyword argument is recommended.)</p><p>To try these functions, open a graphics-drawing application such as Paint on Windows, Paintbrush on OS X, or GNU Paint on Linux. (If you don’t have a drawing application, you can use the online one at <span class="emphasis"><em><a class="ulink" href="http://sumopaint.com/">http://sumopaint.com/</a></em></span>.) I will use PyAutoGUI to draw in these applications.</p><p>With the mouse cursor over the drawing application’s canvas and the Pencil or Brush tool selected, enter the following into a new file editor window and save it as <span class="emphasis"><em>spiralDraw.py</em></span>:</p><a id="pro_id00636"/><pre class="programlisting">   import pyautogui, time
➊ time.sleep(5)
➋ pyautogui.click()    # click to put drawing program in focus
   distance = 200
   while distance &gt; 0:
➌     pyautogui.dragRel(distance, 0, duration=0.2)   # move right
➍     distance = distance - 5
➎     pyautogui.dragRel(0, distance, duration=0.2)   # move down
➏     pyautogui.dragRel(-distance, 0, duration=0.2)  # move left
       distance = distance - 5
       pyautogui.dragRel(0, -distance, duration=0.2)  # move up</pre><p>When you run this program, there will be a five-second delay ➊ for you to move the mouse cursor over the drawing program’s window with the Pencil or Brush tool selected. Then <span class="emphasis"><em>spiralDraw.py</em></span> will take control of the mouse and click to put the drawing program in focus ➋. A window is in <span class="emphasis"><em>focus</em></span> when it has an active blinking cursor, and the actions you take—like typing or, in this case, dragging the mouse—will affect that window. Once the drawing program is in focus, <span class="emphasis"><em>spiralDraw.py</em></span> draws a square spiral pattern like the one in <a class="xref" href="ch18.html#results_from_the_pyautoguidotdragrelleft" title="Figure 18-2. The results from the pyautogui.dragRel() example">Figure 18-2</a>.</p><div class="figure"><a id="results_from_the_pyautoguidotdragrelleft"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00098"/><img src="figs/web/18fig02.png.jpg" alt="The results from the pyautogui.dragRel() example"/></div></div><p class="title">Figure 18-2. The results from the <code class="literal">pyautogui.dragRel()</code> example</p></div><p><a id="iddle1360" class="indexterm"/><a id="iddle1637" class="indexterm"/><a id="iddle1954" class="indexterm"/><a id="iddle2221" class="indexterm"/><a id="iddle2383" class="indexterm"/><a id="iddle2386" class="indexterm"/>The <code class="literal">distance</code> variable starts at <code class="literal">200</code>, so on the first iteration of the <code class="literal">while</code> loop, the first <code class="literal">dragRel()</code> call drags the cursor 200 pixels to the right, taking 0.2 seconds ➌. <code class="literal">distance</code> is then decreased to 195 ➍, and the second <code class="literal">dragRel()</code> call drags the cursor 195 pixels down ➎. The third <code class="literal">dragRel()</code> call drags the cursor –195 horizontally (195 to the left) ➏, <code class="literal">distance</code> is decreased to 190, and the last <code class="literal">dragRel()</code> call drags the cursor 190 pixels up. On each iteration, the mouse is dragged right, down, left, and up, and <code class="literal">distance</code> is slightly smaller than it was in the previous iteration. By looping over this code, you can move the mouse cursor to draw a square spiral.</p><p>You could draw this spiral by hand (or rather, by mouse), but you’d have to work slowly to be so precise. PyAutoGUI can do it in a few seconds!</p><div class="note" title="Note"><h3 class="title"><a id="ch18note01"/>Note</h3><p><span class="emphasis"><em>You could have your code draw the image using the</em></span> <code class="literal">pillow</code> <span class="emphasis"><em>module’s drawing functions—see <a class="xref" href="ch17.html" title="Chapter 17. Manipulating Images">Chapter 17</a> for more information. But using GUI automation allows you to make use of the advanced drawing tools that graphics programs can provide, such as gradients, different brushes, or the fill bucket.</em></span></p></div></div><div class="sect2" title="Scrolling the Mouse"><div class="titlepage"><div><div><h2 class="title"><a id="scrolling_the_mouse"/>Scrolling the Mouse</h2></div></div></div><p>The final PyAutoGUI mouse function is <code class="literal">scroll()</code>, which you pass an integer argument for how many units you want to scroll the mouse up or down. The size of a unit varies for each operating system and application, so you’ll have to experiment to see exactly how far it scrolls in your particular situation. The scrolling takes place at the mouse cursor’s current position. Passing a positive integer scrolls up, and passing a negative integer scrolls down. Run the following in IDLE’s interactive shell while the mouse cursor is over the IDLE window:</p><a id="pro_id00637"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>pyautogui.scroll(200)</strong></span></pre><p>You’ll see IDLE briefly scroll upward—and then go back down. The downward scrolling happens because IDLE automatically scrolls down to the bottom after executing an instruction. Enter this code instead:</p><a id="pro_id00638"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import pyperclip</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>numbers = ''</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>for i in range(200):</strong></span>
      <span class="strong"><strong>numbers = numbers + str(i) + '\n'</strong></span>

&gt;&gt;&gt; <span class="strong"><strong>pyperclip.copy(numbers)</strong></span></pre><p>This imports <code class="literal">pyperclip</code> and sets up an empty string, <code class="literal">numbers</code>. The code then loops through 200 numbers and adds each number to <code class="literal">numbers</code>, along with a newline. After <code class="literal">pyperclip.copy(numbers)</code>, the clipboard will be loaded with 200 lines of numbers. Open a new file editor window and paste the text into it. This will give you a large text window to try scrolling in. Enter the following code into the interactive shell:</p><a id="pro_id00639"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import time, pyautogui</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>time.sleep(5); pyautogui.scroll(100)</strong></span></pre><p><a id="iddle1597" class="indexterm"/><a id="iddle1643" class="indexterm"/><a id="iddle1712" class="indexterm"/><a id="iddle2229" class="indexterm"/><a id="iddle2238" class="indexterm"/><a id="iddle2377" class="indexterm"/><a id="iddle2380" class="indexterm"/><a id="iddle2384" class="indexterm"/>On the second line, you enter two commands separated by a semicolon, which tells Python to run the commands as if they were on separate lines. The only difference is that the interactive shell won’t prompt you for input between the two instructions. This is important for this example because we want to the call to <code class="literal">pyautogui.scroll()</code> to happen automatically after the wait. (Note that while putting two commands on one line can be useful in the interactive shell, you should still have each instruction on a separate line in your programs.)</p><p>After pressing <span class="smaller">ENTER</span> to run the code, you will have five seconds to click the file editor window to put it in focus. Once the pause is over, the <code class="literal">pyautogui.scroll()</code> call will cause the file editor window to scroll up after the five-second delay.</p></div></div><div class="sect1" title="Working with the Screen"><div class="titlepage"><div><div><h1 class="title"><a id="working_with_the_screen"/>Working with the Screen</h1></div></div></div><p>Your GUI automation programs don’t have to click and type blindly. PyAutoGUI has screenshot features that can create an image file based on the current contents of the screen. These functions can also return a Pillow <code class="literal">Image</code> object of the current screen’s appearance. If you’ve been skipping around in this book, you’ll want to read <a class="xref" href="ch17.html" title="Chapter 17. Manipulating Images">Chapter 17</a> and install the <code class="literal">pillow</code> module before continuing with this section.</p><p>On Linux computers, the <code class="literal">scrot</code> program needs to be installed to use the screenshot functions in PyAutoGUI. In a Terminal window, run <span class="strong"><strong><code class="literal">sudo apt-get install scrot</code></strong></span> to install this program. If you’re on Windows or OS X, skip this step and continue with the section.</p><div class="sect2" title="Getting a Screenshot"><div class="titlepage"><div><div><h2 class="title"><a id="getting_a_screenshot"/>Getting a Screenshot</h2></div></div></div><p>To take screenshots in Python, call the <code class="literal">pyautogui.screenshot()</code> function. Enter the following into the interactive shell:</p><a id="pro_id00640"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import pyautogui</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>im = pyautogui.screenshot()</strong></span></pre><p>The <code class="literal">im</code> variable will contain the <code class="literal">Image</code> object of the screenshot. You can now call methods on the <code class="literal">Image</code> object in the <code class="literal">im</code> variable, just like any other <code class="literal">Image</code> object. Enter the following into the interactive shell:</p><a id="pro_id00641"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>im.getpixel((0, 0))</strong></span>
(176, 176, 175)
&gt;&gt;&gt; <span class="strong"><strong>im.getpixel((50, 200))</strong></span>
(130, 135, 144)</pre><p>Pass <code class="literal">getpixel()</code> a tuple of coordinates, like (0, 0) or (50, 200), and it’ll tell you the color of the pixel at those coordinates in your image. The return value from <code class="literal">getpixel()</code> is an RGB tuple of three integers for the amount of red, green, and blue in the pixel. (There is no fourth value for alpha, because screenshot images are fully opaque.) This is how your programs can “see” what is currently on the screen.</p></div><div class="sect2" title="Analyzing the Screenshot"><div class="titlepage"><div><div><h2 class="title"><a id="analyzing_the_screenshot"/>Analyzing the Screenshot</h2></div></div></div><p><a id="iddle1598" class="indexterm"/><a id="iddle1962" class="indexterm"/><a id="iddle2128" class="indexterm"/><a id="iddle2183" class="indexterm"/><a id="iddle2379" class="indexterm"/>Say that one of the steps in your GUI automation program is to click a gray button. Before calling the <code class="literal">click()</code> method, you could take a screenshot and look at the pixel where the script is about to click. If it’s not the same gray as the gray button, then your program knows something is wrong. Maybe the window moved unexpectedly, or maybe a pop-up dialog has blocked the button. At this point, instead of continuing—and possibly wreaking havoc by clicking the wrong thing—your program can “see” that it isn’t clicking on the right thing and stop itself.</p><p>PyAutoGUI’s <code class="literal">pixelMatchesColor()</code> function will return <code class="literal">True</code> if the pixel at the given x- and y-coordinates on the screen matches the given color. The first and second arguments are integers for the x- and y-coordinates, and the third argument is a tuple of three integers for the RGB color the screen pixel must match. Enter the following into the interactive shell:</p><a id="pro_id00642"/><pre class="programlisting">   &gt;&gt;&gt; <span class="strong"><strong>import pyautogui</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>im = pyautogui.screenshot()</strong></span>
➊ &gt;&gt;&gt; <span class="strong"><strong>im.getpixel((50, 200))</strong></span>
   (130, 135, 144)
➋ &gt;&gt;&gt; <span class="strong"><strong>pyautogui.pixelMatchesColor(50, 200, (130, 135, 144))</strong></span>
   True
➌ &gt;&gt;&gt; <span class="strong"><strong>pyautogui.pixelMatchesColor(50, 200, (255, 135, 144))</strong></span>
   False</pre><p>After taking a screenshot and using <code class="literal">getpixel()</code> to get an RGB tuple for the color of a pixel at specific coordinates ➊, pass the same coordinates and RGB tuple to <code class="literal">pixelMatchesColor()</code> ➋, which should return <code class="literal">True</code>. Then change a value in the RGB tuple and call <code class="literal">pixelMatchesColor()</code> again for the same coordinates ➌. This should return <code class="literal">false</code>. This method can be useful to call whenever your GUI automation programs are about to call <code class="literal">click()</code>. Note that the color at the given coordinates must <span class="emphasis"><em>exactly</em></span> match. If it is even slightly different—for example, <code class="literal">(255, 255, 254)</code> instead of <code class="literal">(255, 255, 255)</code>—then <code class="literal">pixelMatchesColor()</code> will return <code class="literal">False</code>.</p></div></div><div class="sect1" title="Project: Extending the mouseNow Program"><div class="titlepage"><div><div><h1 class="title"><a id="project_extending_the_mousenow_program"/>Project: Extending the mouseNow Program</h1></div></div></div><p>You could extend the <span class="emphasis"><em>mouseNow.py</em></span> project from earlier in this chapter so that it not only gives the x- and y-coordinates of the mouse cursor’s current position but also gives the RGB color of the pixel under the cursor. Modify the code inside the <code class="literal">while</code> loop of <span class="emphasis"><em>mouseNow.py</em></span> to look like this:</p><a id="pro_id00643"/><pre class="programlisting">#! python3
# mouseNow.py - Displays the mouse cursor's current position.
--<span class="emphasis"><em>snip</em></span>--
        positionStr = 'X: ' + str(x).rjust(4) + ' Y: ' + str(y).rjust(4)
        <span class="strong"><strong>pixelColor = pyautogui.screenshot().getpixel((x, y))</strong></span>
        <span class="strong"><strong>positionStr += ' RGB: (' + str(pixelColor[0]).rjust(3)</strong></span>
        <span class="strong"><strong>positionStr += ', ' + str(pixelColor[1]).rjust(3)</strong></span>
        <span class="strong"><strong>positionStr += ', ' + str(pixelColor[2]).rjust(3) + ')'</strong></span>
        print(positionStr, end='')
--<span class="emphasis"><em>snip</em></span>--</pre><p><a id="iddle1639" class="indexterm"/><a id="iddle1694" class="indexterm"/><a id="iddle1865" class="indexterm"/><a id="iddle2225" class="indexterm"/>Now, when you run <span class="emphasis"><em>mouseNow.py</em></span>, the output will include the RGB color value of the pixel under the mouse cursor.</p><a id="pro_id00644"/><pre class="programlisting">Press Ctrl-C to quit.
X:  406 Y:   17 RGB: (161, 50, 50)</pre><p>This information, along with the <code class="literal">pixelMatchesColor()</code> function, should make it easy to add pixel color checks to your GUI automation scripts.</p></div><div class="sect1" title="Image Recognition"><div class="titlepage"><div><div><h1 class="title"><a id="image_recognition"/>Image Recognition</h1></div></div></div><p>But what if you do not know beforehand where PyAutoGUI should click? You can use image recognition instead. Give PyAutoGUI an image of what you want to click and let it figure out the coordinates.</p><p>For example, if you have previously taken a screenshot to capture the image of a Submit button in <span class="emphasis"><em>submit.png</em></span>, the <code class="literal">locateOnScreen()</code> function will return the coordinates where that image is found. To see how <code class="literal">locateOnScreen()</code> works, try taking a screenshot of a small area on your screen; then save the image and enter the following into the interactive shell, replacing <code class="literal">'submit. png'</code> with the filename of your screenshot:</p><a id="pro_id00645"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import pyautogui</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.locateOnScreen('submit.png')</strong></span>
(643, 745, 70, 29)</pre><p>The four-integer tuple that <code class="literal">locateOnScreen()</code> returns has the x-coordinate of the left edge, the y-coordinate of the top edge, the width, and the height for the first place on the screen the image was found. If you’re trying this on your computer with your own screenshot, your return value will be different from the one shown here.</p><p>If the image cannot be found on the screen, <code class="literal">locateOnScreen()</code> will return <code class="literal">None</code>. Note that the image on the screen must match the provided image perfectly in order to be recognized. If the image is even a pixel off, <code class="literal">locateOnScreen()</code> will return <code class="literal">None</code>.</p><p>If the image can be found in several places on the screen, <code class="literal">locateAllOnScreen()</code> will return a <code class="literal">Generator</code> object, which can be passed to <code class="literal">list()</code> to return a list of four-integer tuples. There will be one four-integer tuple for each location where the image is found on the screen. Continue the interactive shell example by entering the following (and replacing <code class="literal">'submit.png'</code> with your own image filename):</p><a id="pro_id00646"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>list(pyautogui.locateAllOnScreen('submit.png'))</strong></span>
[(643, 745, 70, 29), (1007, 801, 70, 29)]</pre><p><a id="iddle1165" class="indexterm"/><a id="iddle1628" class="indexterm"/><a id="iddle1632" class="indexterm"/><a id="iddle1778" class="indexterm"/><a id="iddle1831" class="indexterm"/><a id="iddle1864" class="indexterm"/><a id="iddle2212" class="indexterm"/><a id="iddle2216" class="indexterm"/><a id="iddle2240" class="indexterm"/><a id="iddle2601" class="indexterm"/>Each of the four-integer tuples represents an area on the screen. If your image is only found in one area, then using <code class="literal">list()</code> and <code class="literal">locateAllOnScreen()</code> just returns a list containing one tuple.</p><p>Once you have the four-integer tuple for the area on the screen where your image was found, you can click the center of this area by passing the tuple to the <code class="literal">center()</code> function to return x- and y-coordinates of the area’s center. Enter the following into the interactive shell, replacing the arguments with your own filename, four-integer tuple, and coordinate pair:</p><a id="pro_id00647"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>pyautogui.locateOnScreen('submit.png')</strong></span>
(643, 745, 70, 29)
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.center((643, 745, 70, 29))</strong></span>
(678, 759)
&gt;&gt;&gt; <span class="strong"><strong>pyautogui.click((678, 759))</strong></span></pre><p>Once you have center coordinates from <code class="literal">center()</code>, passing the coordinates to <code class="literal">click()</code> should click the center of the area on the screen that matches the image you passed to <code class="literal">locateOnScreen()</code>.</p></div><div class="sect1" title="Controlling the Keyboard"><div class="titlepage"><div><div><h1 class="title"><a id="controlling_the_keyboard"/>Controlling the Keyboard</h1></div></div></div><p>PyAutoGUI also has functions for sending virtual keypresses to your computer, which enables you to fill out forms or enter text into applications.</p><div class="sect2" title="Sending a String from the Keyboard"><div class="titlepage"><div><div><h2 class="title"><a id="sending_a_string_from_the_keyboard"/>Sending a String from the Keyboard</h2></div></div></div><p>The <code class="literal">pyautogui.typewrite()</code> function sends virtual keypresses to the computer. What these keypresses do depends on what window and text field have focus. You may want to first send a mouse click to the text field you want in order to ensure that it has focus.</p><p>As a simple example, let’s use Python to automatically type the words <span class="emphasis"><em>Hello world!</em></span> into a file editor window. First, open a new file editor window and position it in the upper-left corner of your screen so that PyAutoGUI will click in the right place to bring it into focus. Next, enter the following into the interactive shell:</p><a id="pro_id00648"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>pyautogui.click(100, 100); pyautogui.typewrite('Hello world!')</strong></span></pre><p>Notice how placing two commands on the same line, separated by a semicolon, keeps the interactive shell from prompting you for input between running the two instructions. This prevents you from accidentally bringing a new window into focus between the <code class="literal">click()</code> and <code class="literal">typewrite()</code> calls, which would mess up the example.</p><p>Python will first send a virtual mouse click to the coordinates (100, 100), which should click the file editor window and put it in focus. The <code class="literal">typewrite()</code> call will send the text <span class="emphasis"><em>Hello world!</em></span> to the window, making it look like <a class="xref" href="ch18.html#using_pyautoggui_to_click_the_file_edito" title="Figure 18-3. Using PyAutogGUI to click the file editor window and type Hello world! into it">Figure 18-3</a>. You now have code that can type for you!</p><div class="figure"><a id="using_pyautoggui_to_click_the_file_edito"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00099"/><img src="figs/web/18fig03.png.jpg" alt="Using PyAutogGUI to click the file editor window and type Hello world! into it"/></div></div><p class="title">Figure 18-3. Using PyAutogGUI to click the file editor window and type <span class="emphasis"><em>Hello world!</em></span> into it</p></div><p><a id="iddle1630" class="indexterm"/><a id="iddle1779" class="indexterm"/><a id="iddle2214" class="indexterm"/><a id="iddle2241" class="indexterm"/><a id="iddle2602" class="indexterm"/>By default, the <code class="literal">typewrite()</code> function will type the full string instantly. However, you can pass an optional second argument to add a short pause between each character. This second argument is an integer or float value of the number of seconds to pause. For example, <code class="literal">pyautogui.typewrite('Hello world!', 0.25)</code> will wait a quarter-second after typing <span class="emphasis"><em>H</em></span>, another quarter-second after <span class="emphasis"><em>e</em></span>, and so on. This gradual typewriter effect may be useful for slower applications that can’t process keystrokes fast enough to keep up with PyAutoGUI.</p><p>For characters such as <span class="emphasis"><em>A</em></span> or <span class="emphasis"><em>!</em></span>, PyAutoGUI will automatically simulate holding down the <span class="smaller">SHIFT</span> key as well.</p></div><div class="sect2" title="Key Names"><div class="titlepage"><div><div><h2 class="title"><a id="key_names"/>Key Names</h2></div></div></div><p>Not all keys are easy to represent with single text characters. For example, how do you represent <span class="smaller">SHIFT</span> or the left arrow key as a single character? In PyAutoGUI, these keyboard keys are represented by short string values instead: <code class="literal">'esc'</code> for the <span class="smaller">ESC</span> key or <code class="literal">'enter'</code> for the <span class="smaller">ENTER</span> key.</p><p>Instead of a single string argument, a list of these keyboard key strings can be passed to <code class="literal">typewrite()</code>. For example, the following call presses the A key, then the B key, then the left arrow key twice, and finally the X and Y keys:</p><a id="pro_id00649"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>pyautogui.typewrite(['a', 'b', 'left', 'left', 'X', 'Y'])</strong></span></pre><p>Because pressing the left arrow key moves the keyboard cursor, this will output <span class="emphasis"><em>XYab</em></span>. <a class="xref" href="ch18.html#pykeyboard_attributes" title="Table 18-1. PyKeyboard Attributes">Table 18-1</a> lists the PyAutoGUI keyboard key strings that you can pass to <code class="literal">typewrite()</code> to simulate pressing any combination of keys.</p><p>You can also examine the <code class="literal">pyautogui.KEYBOARD_KEYS</code> list to see all possible keyboard key strings that PyAutoGUI will accept. The <code class="literal">'shift'</code> string refers to the left <span class="smaller">SHIFT</span> key and is equivalent to <code class="literal">'shiftleft'</code>. The same applies for <code class="literal">'ctrl'</code>, <code class="literal">'alt'</code>, and <code class="literal">'win'</code> strings; they all refer to the left-side key.</p><div class="table"><a id="pykeyboard_attributes"/><p class="title">Table 18-1. <code class="literal">PyKeyboard</code> Attributes</p><div class="table-contents"><table summary="PyKeyboard Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1631" class="indexterm"/><a id="iddle1777" class="indexterm"/><a id="iddle1783" class="indexterm"/><a id="iddle1788" class="indexterm"/><a id="iddle2208" class="indexterm"/><a id="iddle2209" class="indexterm"/><a id="iddle2215" class="indexterm"/>Keyboard key string</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Meaning</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'a'</code>, <code class="literal">'b'</code>, <code class="literal">'c'</code>, <code class="literal">'A'</code>, <code class="literal">'B'</code>, <code class="literal">'C'</code>, <code class="literal">'1'</code>, <code class="literal">'2'</code>, <code class="literal">'3'</code>, <code class="literal">'!'</code>, <code class="literal">'@'</code>, <code class="literal">'#'</code>, and so on</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The keys for single characters</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'enter'</code> (or <code class="literal">'return'</code> or <code class="literal">'\n'</code>)</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">ENTER</span> key</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'esc'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">ESC</span> key</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'shiftleft'</code>, <code class="literal">'shiftright'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The left and right <span class="smaller">SHIFT</span> keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'altleft'</code>, <code class="literal">'altright'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The left and right <span class="smaller">ALT</span> keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'ctrlleft'</code>, <code class="literal">'ctrlright'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The left and right <span class="smaller">CTRL</span> keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'tab'</code> (or <code class="literal">'\t'</code>)</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">TAB</span> key</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'backspace'</code>, <code class="literal">'delete'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">BACKSPACE</span> and <span class="smaller">DELETE</span> keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'pageup'</code>, <code class="literal">'pagedown'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">PAGE UP</span> and <span class="smaller">PAGE DOWN</span> keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'home'</code>, <code class="literal">'end'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">HOME</span> and <span class="smaller">END</span> keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'up'</code>, <code class="literal">'down'</code>, <code class="literal">'left'</code>, <code class="literal">'right'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The up, down, left, and right arrow keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'f1'</code>, <code class="literal">'f2'</code>, <code class="literal">'f3'</code>, and so on</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The F1 to F12 keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'volumemute'</code>, <code class="literal">'volumedown'</code>, <code class="literal">'volumeup'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The mute, volume down, and volume up keys (some keyboards do not have these keys, but your operating system will still be able to understand these simulated keypresses)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'pause'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">PAUSE</span> key</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'capslock'</code>, <code class="literal">'numlock'</code>, <code class="literal">'scrolllock'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">CAPS LOCK</span>, <span class="smaller">NUM LOCK</span>, and <span class="smaller">SCROLL</span> <span class="smaller">LOCK</span> keys</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'insert'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">INS</span> or <span class="smaller">INSERT</span> key</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'printscreen'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The <span class="smaller">PRTSC</span> or <span class="smaller">PRINT SCREEN</span> key</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">'winleft'</code>, <code class="literal">'winright'</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The left and right <span class="smaller">WIN</span> keys (on Windows)</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">'command'</code></p></td><td style="" valign="top"><p>The Command (<span class="inlinemediaobject"><a id="inline_id00004"/><img src="figs/web/common-01.png.jpg" alt=""/></span>) key (on OS X) <code class="literal">'option'</code> The <span class="smaller">OPTION</span> key (on OS X)</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Pressing and Releasing the Keyboard"><div class="titlepage"><div><div><h2 class="title"><a id="pressing_and_releasing_the_keyboard"/>Pressing and Releasing the Keyboard</h2></div></div></div><p>Much like the <code class="literal">mouseDown()</code> and <code class="literal">mouseUp()</code> functions, <code class="literal">pyautogui.keyDown()</code> and <code class="literal">pyautogui.keyUp()</code> will send virtual keypresses and releases to the computer. They are passed a keyboard key string (see <a class="xref" href="ch18.html#pykeyboard_attributes" title="Table 18-1. PyKeyboard Attributes">Table 18-1</a>) for their argument. For convenience, PyAutoGUI provides the <code class="literal">pyautogui.press()</code> function, which calls both of these functions to simulate a complete keypress.</p><p>Run the following code, which will type a dollar sign character (obtained by holding the <span class="smaller">SHIFT</span> key and pressing 4):</p><a id="pro_id00650"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>pyautogui.keyDown('shift'); pyautogui.press('4'); pyautogui.keyUp('shift')</strong></span></pre><p><a id="iddle1195" class="indexterm"/><a id="iddle1629" class="indexterm"/><a id="iddle1650" class="indexterm"/><a id="iddle1651" class="indexterm"/><a id="iddle1776" class="indexterm"/><a id="iddle1784" class="indexterm"/><a id="iddle1789" class="indexterm"/><a id="iddle2146" class="indexterm"/><a id="iddle2207" class="indexterm"/><a id="iddle2213" class="indexterm"/>This line presses down <span class="smaller">SHIFT</span>, presses (and releases) 4, and then releases <span class="smaller">SHIFT</span>. If you need to type a string into a text field, the <code class="literal">typewrite()</code> function is more suitable. But for applications that take single-key commands, the <code class="literal">press()</code> function is the simpler approach.</p></div><div class="sect2" title="Hotkey Combinations"><div class="titlepage"><div><div><h2 class="title"><a id="hotkey_combinations"/>Hotkey Combinations</h2></div></div></div><p>A <span class="emphasis"><em>hotkey</em></span> or <span class="emphasis"><em>shortcut</em></span> is a combination of keypresses to invoke some application function. The common hotkey for copying a selection is <span class="smaller">CTRL</span>-C (on Windows and Linux) or ⌘-C (on OS X). The user presses and holds the <span class="smaller">CTRL</span> key, then presses the C key, and then releases the C and <span class="smaller">CTRL</span> keys. To do this with PyAutoGUI’s <code class="literal">keyDown()</code> and <code class="literal">keyUp()</code> functions, you would have to enter the following:</p><a id="pro_id00651"/><pre class="programlisting">pyautogui.keyDown('ctrl')
pyautogui.keyDown('c')
pyautogui.keyUp('c')
pyautogui.keyUp('ctrl')</pre><p>This is rather complicated. Instead, use the <code class="literal">pyautogui.hotkey()</code> function, which takes multiple keyboard key string arguments, presses them in order, and releases them in the reverse order. For the <span class="smaller">CTRL</span>-C example, the code would simply be as follows:</p><a id="pro_id00652"/><pre class="programlisting">pyautogui.hotkey('ctrl', 'c')</pre><p>This function is especially useful for larger hotkey combinations. In Word, the <span class="smaller">CTRL</span>-<span class="smaller">ALT</span>-<span class="smaller">SHIFT</span>-S hotkey combination displays the Style pane. Instead of making eight different function calls (four <code class="literal">keyDown()</code> calls and four <code class="literal">keyUp()</code> calls), you can just call <code class="literal">hotkey('ctrl', 'alt', 'shift', 's')</code>.</p><p>With a new IDLE file editor window in the upper-left corner of your screen, enter the following into the interactive shell (in OS X, replace <code class="literal">'alt'</code> with <code class="literal">'ctrl'</code>):</p><a id="pro_id00653"/><pre class="programlisting">   &gt;&gt;&gt; <span class="strong"><strong>import pyautogui, time</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>def commentAfterDelay():</strong></span>
➊       <span class="strong"><strong>pyautogui.click(100, 100)</strong></span>
➋       <span class="strong"><strong>pyautogui.typewrite('In IDLE, Alt-3 comments out a line.')</strong></span>
         <span class="strong"><strong>time.sleep(2)</strong></span>
➌       <span class="strong"><strong>pyautogui.hotkey('alt', '3')</strong></span>

   &gt;&gt;&gt; <span class="strong"><strong>commentAfterDelay()</strong></span></pre><p>This defines a function <code class="literal">commentAfterDelay()</code> that, when called, will click the file editor window to bring it into focus ➊, type <span class="emphasis"><em>In IDLE, Atl-3 comments out a line</em></span> ➋, pause for 2 seconds, and then simulate pressing the <span class="smaller">ALT</span>-3 hotkey (or <span class="smaller">CTRL</span>-3 on OS X) ➌. This keyboard shortcut adds two <span class="emphasis"><em>#</em></span> characters to the current line, commenting it out. (This is a useful trick to know when writing your own code in IDLE.)</p></div></div><div class="sect1" title="Review of the PyAutoGUI Functions"><div class="titlepage"><div><div><h1 class="title"><a id="review_of_the_pyautogui_functions"/>Review of the PyAutoGUI Functions</h1></div></div></div><p><a id="iddle1175" class="indexterm"/><a id="iddle1350" class="indexterm"/><a id="iddle1361" class="indexterm"/><a id="iddle1363" class="indexterm"/><a id="iddle1557" class="indexterm"/><a id="iddle1558" class="indexterm"/><a id="iddle1571" class="indexterm"/><a id="iddle1611" class="indexterm"/><a id="iddle1627" class="indexterm"/><a id="iddle1652" class="indexterm"/><a id="iddle1785" class="indexterm"/><a id="iddle1790" class="indexterm"/><a id="iddle1944" class="indexterm"/><a id="iddle1964" class="indexterm"/><a id="iddle1966" class="indexterm"/><a id="iddle1971" class="indexterm"/><a id="iddle1974" class="indexterm"/><a id="iddle2147" class="indexterm"/><a id="iddle2179" class="indexterm"/><a id="iddle2211" class="indexterm"/><a id="iddle2224" class="indexterm"/><a id="iddle2350" class="indexterm"/><a id="iddle2378" class="indexterm"/><a id="iddle2385" class="indexterm"/><a id="iddle2603" class="indexterm"/>Since this chapter covered many different functions, here is a quick summary reference:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="moveTo(x, y)"><span class="title"><strong><span class="strong"><strong><code class="literal">moveTo(</code><span class="emphasis"><em><code class="literal">x</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">y</code></em></span><code class="literal">)</code></strong></span></strong></span>. Moves the mouse cursor to the given <span class="emphasis"><em><code class="literal">x</code></em></span> and <span class="emphasis"><em><code class="literal">y</code></em></span> coordinates.</p></li><li class="listitem"><p title="moveRel(xOffset, yOffset)"><span class="title"><strong><span class="strong"><strong><code class="literal">moveRel(</code><span class="emphasis"><em><code class="literal">xOffset</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">yOffset</code></em></span><code class="literal">)</code></strong></span></strong></span>. Moves the mouse cursor relative to its current position.</p></li><li class="listitem"><p title="dragTo(x, y)"><span class="title"><strong><span class="strong"><strong><code class="literal">dragTo(</code><span class="emphasis"><em><code class="literal">x</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">y</code></em></span><code class="literal">)</code></strong></span></strong></span>. Moves the mouse cursor while the left button is held down.</p></li><li class="listitem"><p title="dragRel(xOffset, yOffset)"><span class="title"><strong><span class="strong"><strong><code class="literal">dragRel(</code><span class="emphasis"><em><code class="literal">xOffset</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">yOffset</code></em></span><code class="literal">)</code></strong></span></strong></span>. Moves the mouse cursor relative to its current position while the left button is held down.</p></li><li class="listitem"><p title="click(x, y, button)"><span class="title"><strong><span class="strong"><strong><code class="literal">click(</code><span class="emphasis"><em><code class="literal">x</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">y</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">button</code></em></span><code class="literal">)</code></strong></span></strong></span>. Simulates a click (left button by default).</p></li><li class="listitem"><p title="rightClick()"><span class="title"><strong><span class="strong"><strong><code class="literal">rightClick()</code></strong></span></strong></span>. Simulates a right-button click.</p></li><li class="listitem"><p title="middleClick()"><span class="title"><strong><span class="strong"><strong><code class="literal">middleClick()</code></strong></span></strong></span>. Simulates a middle-button click.</p></li><li class="listitem"><p title="doubleClick()"><span class="title"><strong><span class="strong"><strong><code class="literal">doubleClick()</code></strong></span></strong></span>. Simulates a double left-button click.</p></li><li class="listitem"><p title="mouseDown(x, y, button)"><span class="title"><strong><span class="strong"><strong><code class="literal">mouseDown(</code><span class="emphasis"><em><code class="literal">x</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">y</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">button</code></em></span><code class="literal">)</code></strong></span></strong></span>. Simulates pressing down the given button at the position <span class="emphasis"><em><code class="literal">x</code></em></span>, <span class="emphasis"><em><code class="literal">y</code></em></span>.</p></li><li class="listitem"><p title="mouseUp(x, y, button)"><span class="title"><strong><span class="strong"><strong><code class="literal">mouseUp(</code><span class="emphasis"><em><code class="literal">x</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">y</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">button</code></em></span><code class="literal">)</code></strong></span></strong></span>. Simulates releasing the given button at the position <span class="emphasis"><em><code class="literal">x</code></em></span>, <span class="emphasis"><em><code class="literal">y</code></em></span>.</p></li><li class="listitem"><p title="scroll(units)"><span class="title"><strong><span class="strong"><strong><code class="literal">scroll(</code><span class="emphasis"><em><code class="literal">units</code></em></span><code class="literal">)</code></strong></span></strong></span>. Simulates the scroll wheel. A positive argument scrolls up; a negative argument scrolls down.</p></li><li class="listitem"><p title="typewrite(message)"><span class="title"><strong><span class="strong"><strong><code class="literal">typewrite(</code><span class="emphasis"><em><code class="literal">message</code></em></span><code class="literal">)</code></strong></span></strong></span>. Types the characters in the given message string.</p></li><li class="listitem"><p title="typewrite([key1, key2, key3])"><span class="title"><strong><span class="strong"><strong><code class="literal">typewrite([</code><span class="emphasis"><em><code class="literal">key1</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">key2</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">key3</code></em></span><code class="literal">])</code></strong></span></strong></span>. Types the given keyboard key strings.</p></li><li class="listitem"><p title="press(key)"><span class="title"><strong><span class="strong"><strong><code class="literal">press(</code><span class="emphasis"><em><code class="literal">key</code></em></span><code class="literal">)</code></strong></span></strong></span>. Presses the given keyboard key string.</p></li><li class="listitem"><p title="keyDown(key)"><span class="title"><strong><span class="strong"><strong><code class="literal">keyDown(</code><span class="emphasis"><em><code class="literal">key</code></em></span><code class="literal">)</code></strong></span></strong></span>. Simulates pressing down the given keyboard key.</p></li><li class="listitem"><p title="keyUp(key)"><span class="title"><strong><span class="strong"><strong><code class="literal">keyUp(</code><span class="emphasis"><em><code class="literal">key</code></em></span><code class="literal">)</code></strong></span></strong></span>. Simulates releasing the given keyboard key.</p></li><li class="listitem"><p title="hotkey([key1, key2, key3])"><span class="title"><strong><span class="strong"><strong><code class="literal">hotkey([</code><span class="emphasis"><em><code class="literal">key1</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">key2</code></em></span><code class="literal">,</code> <span class="emphasis"><em><code class="literal">key3</code></em></span><code class="literal">])</code></strong></span></strong></span>. Simulates pressing the given keyboard key strings down in order and then releasing them in reverse order.</p></li><li class="listitem"><p title="screenshot()"><span class="title"><strong><span class="strong"><strong><code class="literal">screenshot()</code></strong></span></strong></span>. Returns a screenshot as an <code class="literal">Image</code> object. (See <a class="xref" href="ch17.html" title="Chapter 17. Manipulating Images">Chapter 17</a> for information on <code class="literal">Image</code> objects.)</p></li></ul></div></div><div class="sect1" title="Project: Automatic Form Filler"><div class="titlepage"><div><div><h1 class="title"><a id="project_automatic_form_filler"/>Project: Automatic Form Filler</h1></div></div></div><p>Of all the boring tasks, filling out forms is the most dreaded of chores. It’s only fitting that now, in the final chapter project, you will slay it. Say you have a huge amount of data in a spreadsheet, and you have to tediously retype it into some other application’s form interface—with no intern to do it for you. Although some applications will have an Import feature that will allow you to upload a spreadsheet with the information, sometimes it seems that there is no other way than mindlessly clicking and typing for hours on end. You’ve come this far in this book; you know that <span class="emphasis"><em>of course</em></span> there’s another way.</p><p><a id="iddle1176" class="indexterm"/><a id="iddle1562" class="indexterm"/><a id="iddle2202" class="indexterm"/><a id="iddle2242" class="indexterm"/><a id="iddle2604" class="indexterm"/>The form for this project is a Google Docs form that you can find at <span class="emphasis"><em><a class="ulink" href="http://nostarch.com/automatestuff">http://nostarch.com/automatestuff</a></em></span>. It looks like <a class="xref" href="ch18.html#form_used_for_this_project" title="Figure 18-4. The form used for this project">Figure 18-4</a>.</p><div class="figure"><a id="form_used_for_this_project"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00100"/><img src="figs/web/18fig04.png.jpg" alt="The form used for this project"/></div></div><p class="title">Figure 18-4. The form used for this project</p></div><p>At a high level, here’s what your program should do:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Click the first text field of the form.</p></li><li class="listitem"><p>Move through the form, typing information into each field.</p></li><li class="listitem"><p>Click the Submit button.</p></li><li class="listitem"><p>Repeat the process with the next set of data.</p></li></ul></div><p>This means your code will need to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Call <code class="literal">pyautogui.click()</code> to click the form and Submit button.</p></li><li class="listitem"><p>Call <code class="literal">pyautogui.typewrite()</code> to enter text into the fields.</p></li><li class="listitem"><p>Handle the <code class="literal">KeyboardInterrupt</code> exception so the user can press <span class="smaller">CTRL</span>-C to quit.</p></li></ul></div><p>Open a new file editor window and save it as <span class="emphasis"><em>formFiller.py</em></span>.</p><div class="sect2" title="Step 1: Figure Out the Steps"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_figure_out_the_steps"/>Step 1: Figure Out the Steps</h2></div></div></div><p><a id="iddle1561" class="indexterm"/><a id="iddle2532" class="indexterm"/><a id="iddle2534" class="indexterm"/>Before writing code, you need to figure out the exact keystrokes and mouse clicks that will fill out the form once. The <span class="emphasis"><em>mouseNow.py</em></span> script in <a class="xref" href="ch18.html#project_quotation_markwhere_is_the_mouse" title="Project: “Where Is the Mouse Right Now?”">Project: “Where Is the Mouse Right Now?”</a> can help you figure out specific mouse coordinates. You need to know only the coordinates of the first text field. After clicking the first field, you can just press <span class="smaller">TAB</span> to move focus to the next field. This will save you from having to figure out the x- and y-coordinates to click for every field.</p><p>Here are the steps for entering data into the form:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Click the Name field. (Use <span class="emphasis"><em>mouseNow.py</em></span> to determine the coordinates after maximizing the browser window. On OS X, you may need to click twice: once to put the browser in focus and again to click the Name field.)</p></li><li class="listitem"><p>Type a name and then press <span class="smaller">TAB</span>.</p></li><li class="listitem"><p>Type a greatest fear and then press <span class="smaller">TAB</span>.</p></li><li class="listitem"><p>Press the down arrow key the correct number of times to select the wizard power source: once for <span class="emphasis"><em>wand</em></span>, twice for <span class="emphasis"><em>amulet</em></span>, three times for <span class="emphasis"><em>crystal ball</em></span>, and four times for <span class="emphasis"><em>money</em></span>. Then press <span class="smaller">TAB</span>. (Note that on OS X, you will have to press the down arrow key one more time for each option. For some browsers, you may need to press the <span class="smaller">ENTER</span> key as well.)</p></li><li class="listitem"><p>Press the right arrow key to select the answer to the RoboCop question. Press it once for <span class="emphasis"><em>2</em></span>, twice for <span class="emphasis"><em>3</em></span>, three times for <span class="emphasis"><em>4</em></span>, or four times for <span class="emphasis"><em>5</em></span>; or just press the spacebar to select <span class="emphasis"><em>1</em></span> (which is highlighted by default). Then press <span class="smaller">TAB</span>.</p></li><li class="listitem"><p>Type an additional comment and then press <span class="smaller">TAB</span>.</p></li><li class="listitem"><p>Press the <span class="smaller">ENTER</span> key to “click” the Submit button.</p></li><li class="listitem"><p>After submitting the form, the browser will take you to a page where you will need to click a link to return to the form page.</p></li></ol></div><p>Note that if you run this program again later, you may have to update the mouse click coordinates, since the browser window might have changed position. To work around this, always make sure the browser window is maximized before finding the coordinates of the first form field. Also, different browsers on different operating systems might work slightly differently from the steps given here, so check that these keystroke combinations work for your computer before running your program.</p></div><div class="sect2" title="Step 2: Set Up Coordinates"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_set_up_coordinates"/>Step 2: Set Up Coordinates</h2></div></div></div><p>Load the example form you downloaded (<a class="xref" href="ch18.html#form_used_for_this_project" title="Figure 18-4. The form used for this project">Figure 18-4</a>) in a browser and maximize your browser window. Open a new Terminal or command line window to run the <span class="emphasis"><em>mouseNow.py</em></span> script, and then mouse over the Name field to figure out its the x- and y-coordinates. These numbers will be assigned to the <code class="literal">nameField</code> variable in your program. Also, find out the x- and y-coordinates and RGB tuple value of the blue Submit button. These values will be assigned to the <code class="literal">submitButton</code> and <code class="literal">submitButtonColor</code> variables, respectively.</p><p>Next, fill in some dummy data for the form and click <span class="strong"><strong>Submit</strong></span>. You need to see what the next page looks like so that you can use <span class="emphasis"><em>mouseNow.py</em></span> to find the coordinates of the <span class="emphasis"><em>Submit another response</em></span> link on this new page.</p><p>Make your source code look like the following, being sure to replace all the values in italics with the coordinates you determined from your own tests:</p><a id="pro_id00654"/><pre class="programlisting">#! python3
# formFiller.py - Automatically fills in the form.

import pyautogui, time

# Set these to the correct coordinates for your computer.
nameField = (<span class="emphasis"><em>648</em></span>, <span class="emphasis"><em>319</em></span>)
submitButton = (<span class="emphasis"><em>651</em></span>, <span class="emphasis"><em>817</em></span>)
submitButtonColor = (<span class="emphasis"><em>75</em></span>, <span class="emphasis"><em>141</em></span>, <span class="emphasis"><em>249</em></span>)
submitAnotherLink = (<span class="emphasis"><em>760</em></span>, <span class="emphasis"><em>224</em></span>)

# TODO: Give the user a chance to kill the script.

# TODO: Wait until the form page has loaded.

# TODO: Fill out the Name Field.

# TODO: Fill out the Greatest Fear(s) field.

# TODO: Fill out the Source of Wizard Powers field.

# TODO: Fill out the RoboCop field.

# TODO: Fill out the Additional Comments field.

# TODO: Click Submit.

# TODO: Wait until form page has loaded.

# TODO: Click the Submit another response link.</pre><p>Now you need the data you actually want to enter into this form. In the real world, this data might come from a spreadsheet, a plaintext file, or a website, and it would require additional code to load into the program. But for this project, you’ll just hardcode all this data in a variable. Add the following to your program:</p><a id="pro_id00655"/><pre class="programlisting">#! python3
# formFiller.py - Automatically fills in the form.

--<span class="emphasis"><em>snip</em></span>--

<span class="strong"><strong>formData = [{'name': 'Alice', 'fear': 'eavesdroppers', 'source': 'wand',</strong></span>
            <span class="strong"><strong>'robocop': 4, 'comments': 'Tell Bob I said hi.'},</strong></span>
            <span class="strong"><strong>{'name': 'Bob', 'fear': 'bees', 'source': 'amulet', 'robocop': 4,</strong></span>
            <span class="strong"><strong>'comments': 'n/a'},</strong></span>
            <span class="strong"><strong>{'name': 'Carol', 'fear': 'puppets', 'source': 'crystal ball',</strong></span>
            <span class="strong"><strong>'robocop': 1, 'comments': 'Please take the puppets out of the</strong></span>
            <span class="strong"><strong>break room.'},</strong></span>
            <span class="strong"><strong>{'name': 'Alex Murphy', 'fear': 'ED-209', 'source': 'money',</strong></span>
            <span class="strong"><strong>'robocop': 5, 'comments': 'Protect the innocent. Serve the public</strong></span>
            <span class="strong"><strong>trust. Uphold the law.'},</strong></span>
           <span class="strong"><strong>]</strong></span>

--<span class="emphasis"><em>snip</em></span>--</pre><p><a id="iddle1467" class="indexterm"/><a id="iddle1556" class="indexterm"/><a id="iddle1564" class="indexterm"/><a id="iddle2083" class="indexterm"/>The <code class="literal">formData</code> list contains four dictionaries for four different names. Each dictionary has names of text fields as keys and responses as values. The last bit of setup is to set PyAutoGUI’s <code class="literal">PAUSE</code> variable to wait half a second after each function call. Add the following to your program after the <code class="literal">formData</code> assignment statement:</p><a id="pro_id00656"/><pre class="programlisting">pyautogui.PAUSE = 0.5</pre></div><div class="sect2" title="Step 3: Start Typing Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_start_typing_data"/>Step 3: Start Typing Data</h2></div></div></div><p>A <code class="literal">for</code> loop will iterate over each of the dictionaries in the <code class="literal">formData</code> list, passing the values in the dictionary to the PyAutoGUI functions that will virtually type in the text fields.</p><p>Add the following code to your program:</p><a id="pro_id00657"/><pre class="programlisting">   #! python3
   # formFiller.py - Automatically fills in the form.

   --<span class="emphasis"><em>snip</em></span>--

   <span class="strong"><strong>for person in formData:</strong></span>
       <span class="strong"><strong># Give the user a chance to kill the script.</strong></span>
       <span class="strong"><strong>print('&gt;&gt;&gt; 5 SECOND PAUSE TO LET USER PRESS CTRL-C &lt;&lt;&lt;')</strong></span>
➊     <span class="strong"><strong>time.sleep(5)</strong></span>

       <span class="strong"><strong># Wait until the form page has loaded.</strong></span>
➋     <span class="strong"><strong>while not pyautogui.pixelMatchesColor(submitButton[0], submitButton[1],</strong></span>
       <span class="strong"><strong>submitButtonColor):</strong></span>
           <span class="strong"><strong>time.sleep(0.5)</strong></span>

   --<span class="emphasis"><em>snip</em></span>--</pre><p>As a small safety feature, the script has a five-second pause ➊ that gives the user a chance to hit <span class="smaller">CTRL</span>-C (or move the mouse cursor to the upper-left corner of the screen to raise the <code class="literal">FailSafeException</code> exception) to shut the program down in case it’s doing something unexpected. Then the program waits until the Submit button’s color is visible ➋, letting the program know that the form page has loaded. Remember that you figured out the <a id="iddle1559" class="indexterm"/><a id="iddle1560" class="indexterm"/><a id="iddle2129" class="indexterm"/><a id="iddle2149" class="indexterm"/><a id="iddle2282" class="indexterm"/><a id="iddle2398" class="indexterm"/><a id="iddle2533" class="indexterm"/><a id="iddle2605" class="indexterm"/>coordinate and color information in step 2 and stored it in the <code class="literal">submitButton</code> and <code class="literal">submitButtonColor</code> variables. To use <code class="literal">pixelMatchesColor()</code>, you pass the coordinates <code class="literal">submitButton[0]</code> and <code class="literal">submitButton[1]</code>, and the color <code class="literal">submitButtonColor</code>.</p><p>After the code that waits until the Submit button’s color is visible, add the following:</p><a id="pro_id00658"/><pre class="programlisting">   #! python3
   # formFiller.py - Automatically fills in the form.

   --<span class="emphasis"><em>snip</em></span>--

➊     <span class="strong"><strong>print('Entering %s info...' % (person['name']))</strong></span>
➋     <span class="strong"><strong>pyautogui.click(nameField[0], nameField[1])</strong></span>

       <span class="strong"><strong># Fill out the Name field.</strong></span>
➌     <span class="strong"><strong>pyautogui.typewrite(person['name'] + '\t')</strong></span>

       <span class="strong"><strong># Fill out the Greatest Fear(s) field.</strong></span>
➍     <span class="strong"><strong>pyautogui.typewrite(person['fear'] + '\t')</strong></span>

   --<span class="emphasis"><em>snip</em></span>--</pre><p>We add an occasional <code class="literal">print()</code> call to display the program’s status in its Terminal window to let the user know what’s going on ➊.</p><p>Since the program knows that the form is loaded, it’s time to call <code class="literal">click()</code> to click the Name field ➋ and <code class="literal">typewrite()</code> to enter the string in <code class="literal">person['name']</code> ➌. The <code class="literal">'\t'</code> character is added to the end of the string passed to <code class="literal">typewrite()</code> to simulate pressing <span class="smaller">TAB</span>, which moves the keyboard focus to the next field, Greatest Fear(s). Another call to <code class="literal">typewrite()</code> will type the string in <code class="literal">person['fear']</code> into this field and then tab to the next field in the form ➍.</p></div><div class="sect2" title="Step 4: Handle Select Lists and Radio Buttons"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_handle_select_lists_and_radio_but"/>Step 4: Handle Select Lists and Radio Buttons</h2></div></div></div><p>The drop-down menu for the “wizard powers” question and the radio buttons for the RoboCop field are trickier to handle than the text fields. To click these options with the mouse, you would have to figure out the x- and y-coordinates of each possible option. It’s easier to use the keyboard arrow keys to make a selection instead.</p><p>Add the following to your program:</p><a id="pro_id00659"/><pre class="programlisting">   #! python3
   # formFiller.py - Automatically fills in the form.

   --<span class="emphasis"><em>snip</em></span>--

       <span class="strong"><strong># Fill out the Source of Wizard Powers field.</strong></span>
➊     <span class="strong"><strong>if person['source'] == 'wand':</strong></span>
➋         <span class="strong"><strong>pyautogui.typewrite(['down', '\t'])</strong></span>
       <span class="strong"><strong>elif person['source'] == 'amulet':</strong></span>
           <span class="strong"><strong>pyautogui.typewrite(['down', 'down', '\t'])</strong></span>
       <span class="strong"><strong>elif person['source'] == 'crystal ball':</strong></span>
           <span class="strong"><strong>pyautogui.typewrite(['down', 'down', 'down', '\t'])</strong></span>
       <span class="strong"><strong>elif person['source'] == 'money':</strong></span>
           <span class="strong"><strong>pyautogui.typewrite(['down', 'down', 'down', 'down', '\t'])</strong></span>

       <span class="strong"><strong># Fill out the RoboCop field.</strong></span>
➌     <span class="strong"><strong>if person['robocop'] == 1:</strong></span>
➍         <span class="strong"><strong>pyautogui.typewrite([' ', '\t'])</strong></span>
       <span class="strong"><strong>elif person['robocop'] == 2:</strong></span>
           <span class="strong"><strong>pyautogui.typewrite(['right', '\t'])</strong></span>
       <span class="strong"><strong>elif person['robocop'] == 3:</strong></span>
           <span class="strong"><strong>pyautogui.typewrite(['right', 'right', '\t'])</strong></span>
       <span class="strong"><strong>elif person['robocop'] == 4:</strong></span>
           <span class="strong"><strong>pyautogui.typewrite(['right', 'right', 'right', '\t'])</strong></span>
       <span class="strong"><strong>elif person['robocop'] == 5:</strong></span>
           <span class="strong"><strong>pyautogui.typewrite(['right', 'right', 'right', 'right', '\t'])</strong></span>

   --<span class="emphasis"><em>snip</em></span>--</pre><p><a id="iddle1563" class="indexterm"/><a id="iddle2148" class="indexterm"/><a id="iddle2236" class="indexterm"/><a id="iddle2606" class="indexterm"/>Once the drop-down menu has focus (remember that you wrote code to simulate pressing <span class="smaller">TAB</span> after filling out the Greatest Fear(s) field), pressing the down arrow key will move to the next item in the selection list. Depending on the value in <code class="literal">person['source']</code>, your program should send a number of down arrow keypresses before tabbing to the next field. If the value at the <code class="literal">'source'</code> key in this user’s dictionary is <code class="literal">'wand'</code> ➊, we simulate pressing the down arrow key once (to select <span class="emphasis"><em>Wand</em></span>) and pressing <span class="smaller">TAB</span> ➋. If the value at the <code class="literal">'source'</code> key is <code class="literal">'amulet'</code>, we simulate pressing the down arrow key twice and pressing <span class="smaller">TAB</span>, and so on for the other possible answers.</p><p>The radio buttons for the RoboCop question can be selected with the right arrow keys—or, if you want to select the first choice ➌, by just pressing the spacebar ➍.</p></div><div class="sect2" title="Step 5: Submit the Form and Wait"><div class="titlepage"><div><div><h2 class="title"><a id="step_5_submit_the_form_and_wait"/>Step 5: Submit the Form and Wait</h2></div></div></div><p>You can fill out the Additional Comments field with the <code class="literal">typewrite()</code> function by passing <code class="literal">person['comments']</code> as an argument. You can type an additional <code class="literal">'\t'</code> to move the keyboard focus to the next field or the Submit button. Once the Submit button is in focus, calling <code class="literal">pyautogui.press('enter')</code> will simulate pressing the <span class="smaller">ENTER</span> key and submit the form. After submitting the form, your program will wait five seconds for the next page to load.</p><p>Once the new page has loaded, it will have a <span class="emphasis"><em>Submit another response</em></span> link that will direct the browser to a new, empty form page. You stored the coordinates of this link as a tuple in <code class="literal">submitAnotherLink</code> in step 2, so pass these coordinates to <code class="literal">pyautogui.click()</code> to click this link.</p><p>With the new form ready to go, the script’s outer <code class="literal">for</code> loop can continue to the next iteration and enter the next person’s information into the form.</p><p>Complete your program by adding the following code:</p><a id="pro_id00660"/><pre class="programlisting">#! python3
# formFiller.py - Automatically fills in the form.

--<span class="emphasis"><em>snip</em></span>--

    <span class="strong"><strong># Fill out the Additional Comments field.</strong></span>
    <span class="strong"><strong>pyautogui.typewrite(person['comments'] + '\t')</strong></span>

    <span class="strong"><strong># Click Submit.</strong></span>
    <span class="strong"><strong>pyautogui.press('enter')</strong></span>

    <span class="strong"><strong># Wait until form page has loaded.</strong></span>
    <span class="strong"><strong>print('Clicked Submit.')</strong></span>
    <span class="strong"><strong>time.sleep(5)</strong></span>

    <span class="strong"><strong># Click the Submit another response link.</strong></span>
    <span class="strong"><strong>pyautogui.click(submitAnotherLink[0], submitAnotherLink[1])</strong></span></pre><p>Once the main <code class="literal">for</code> loop has finished, the program will have plugged in the information for each person. In this example, there are only four people to enter. But if you had <span class="emphasis"><em>4,000</em></span> people, then writing a program to do this would save you a lot of time and typing!</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00067"/>Summary</h1></div></div></div><p>GUI automation with the <code class="literal">pyautogui</code> module allows you to interact with applications on your computer by controlling the mouse and keyboard. While this approach is flexible enough to do anything that a human user can do, the downside is that these programs are fairly blind to what they are clicking or typing. When writing GUI automation programs, try to ensure that they will crash quickly if they’re given bad instructions. Crashing is annoying, but it’s much better than the program continuing in error.</p><p>You can move the mouse cursor around the screen and simulate mouse clicks, keystrokes, and keyboard shortcuts with PyAutoGUI. The <code class="literal">pyautogui</code> module can also check the colors on the screen, which can provide your GUI automation program with enough of an idea of the screen contents to know whether it has gotten offtrack. You can even give PyAutoGUI a screen-shot and let it figure out the coordinates of the area you want to click.</p><p>You can combine all of these PyAutoGUI features to automate any mindlessly repetitive task on your computer. In fact, it can be downright hypnotic to watch the mouse cursor move on its own and see text appear on the screen automatically. Why not spend the time you saved by sitting back and watching your program do all your work for you? There’s a certain satisfaction that comes from seeing how your cleverness has saved you from the boring stuff.</p></div><div class="sect1" title="Practice Questions"><div class="titlepage"><div><div><h1 class="title"><a id="practice_questions-id00068"/>Practice Questions</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch18qa1"/><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe1"/><a id="ch18qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. How can you trigger PyAutoGUI’s fail safe to stop a program?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe2"/><a id="ch18qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. What function returns the current <code class="literal">resolution()</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe3"/><a id="ch18qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. What function returns the coordinates for the mouse cursor’s current position?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe4"/><a id="ch18qa1q4"/><p>Q:</p></td><td align="left" valign="top"><p>4. What is the difference between <code class="literal">pyautogui.moveTo()</code> and <code class="literal">pyautogui.moveRel()</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe5"/><a id="ch18qa1q5"/><p>Q:</p></td><td align="left" valign="top"><p>5. What functions can be used to drag the mouse?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe6"/><a id="ch18qa1q6"/><p>Q:</p></td><td align="left" valign="top"><p>6. What function call will type out the characters of <code class="literal">"Hello world!"</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe7"/><a id="ch18qa1q7"/><p>Q:</p></td><td align="left" valign="top"><p>7. How can you do keypresses for special keys such as the keyboard’s left arrow key?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe8"/><a id="ch18qa1q8"/><p>Q:</p></td><td align="left" valign="top"><p>8. How can you save the current contents of the screen to an image file named <span class="emphasis"><em>screenshot.png</em></span>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch18qa1qe9"/><a id="ch18qa1q9"/><p>Q:</p></td><td align="left" valign="top"><p>9. What code would set a two second pause after every PyAutoGUI function call?</p></td></tr></tbody></table></div></div><div class="sect1" title="Practice Projects"><div class="titlepage"><div><div><h1 class="title"><a id="practice_projects-id00069"/>Practice Projects</h1></div></div></div><p>For practice, write programs that do the following.</p><div class="sect2" title="Looking Busy"><div class="titlepage"><div><div><h2 class="title"><a id="looking_busy"/>Looking Busy</h2></div></div></div><p>Many instant messaging programs determine whether you are idle, or away from your computer, by detecting a lack of mouse movement over some period of time—say, ten minutes. Maybe you’d like to sneak away from your desk for a while but don’t want others to see your instant messenger status go into idle mode. Write a script to nudge your mouse cursor slightly every ten seconds. The nudge should be small enough so that it won’t get in the way if you do happen to need to use your computer while the script is running.</p></div><div class="sect2" title="Instant Messenger Bot"><div class="titlepage"><div><div><h2 class="title"><a id="instant_messenger_bot"/>Instant Messenger Bot</h2></div></div></div><p>Google Talk, Skype, Yahoo Messenger, AIM, and other instant messaging applications often use proprietary protocols that make it difficult for others to write Python modules that can interact with these programs. But even these proprietary protocols can’t stop you from writing a GUI automation tool.</p><p>The Google Talk application has a search bar that lets you enter a username on your friend list and open a messaging window when you press <span class="smaller">ENTER</span>. The keyboard focus automatically moves to the new window. Other instant messenger applications have similar ways to open new message windows. Write a program that will automatically send out a notification message to a select group of people on your friend list. Your program may have to deal with exceptional cases, such as friends being offline, the chat window appearing at different coordinates on the screen, or confirmation boxes that interrupt your messaging. Your program will have to take screen-shots to guide its GUI interaction and adopt ways of detecting when its virtual keystrokes aren’t being sent.</p><div class="note" title="Note"><h3 class="title"><a id="ch18note02"/>Note</h3><p><span class="emphasis"><em>You may want to set up some fake test accounts so that you don’t accidentally spam your real friends while writing this program.</em></span></p></div></div><div class="sect2" title="Game-Playing Bot Tutorial"><div class="titlepage"><div><div><h2 class="title"><a id="game-playing_bot_tutorial"/>Game-Playing Bot Tutorial</h2></div></div></div><p>There is a great tutorial titled “How to Build a Python Bot That Can Play Web Games” that you can find at <span class="emphasis"><em><a class="ulink" href="http://nostarch.com/automatestuff/">http://nostarch.com/automatestuff/</a></em></span>. This tutorial explains how to create a GUI automation program in Python that plays a Flash game called Sushi Go Round. The game involves clicking the correct ingredient buttons to fill customers’ sushi orders. The faster you fill orders without mistakes, the more points you get. This is a perfectly suited task for a GUI automation program—and a way to cheat to a high score! The tutorial covers many of the same topics that this chapter covers but also includes descriptions of PyAutoGUI’s basic image recognition features.</p></div></div></div></body></html>
