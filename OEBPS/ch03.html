<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 3. Functions</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 3. Functions"><div class="titlepage"><div><div><h1 class="title"><a id="functions"/>Chapter 3. Functions</h1></div></div></div><p><a id="iddle1580" class="indexterm"/>You’re already familiar with the <code class="literal">print()</code>, <code class="literal">input()</code>, and <code class="literal">len()</code> functions from the previous chapters. Python provides several builtin functions like these, but you can also write your own functions. A <span class="emphasis"><em>function</em></span> is like a mini-program within a program.</p><p>To better understand how functions work, let’s create one. Type this program into the file editor and save it as <span class="emphasis"><em>helloFunc.py</em></span>:</p><a id="pro_id00083"/><pre class="programlisting">➊ def hello():
➋     print('Howdy!')
       print('Howdy!!!')
       print('Hello there.')
➌ hello()
   hello()
   hello()</pre><p><a id="iddle1300" class="indexterm"/><a id="iddle1302" class="indexterm"/><a id="iddle2166" class="indexterm"/>The first line is a <code class="literal">def</code> statement ➊, which defines a function named <code class="literal">hello()</code>. The code in the block that follows the <code class="literal">def</code> statement ➋ is the body of the function. This code is executed when the function is called, not when the function is first defined.</p><p>The <code class="literal">hello()</code> lines after the function ➌ are function calls. In code, a function call is just the function’s name followed by parentheses, possibly with some number of arguments in between the parentheses. When the program execution reaches these calls, it will jump to the top line in the function and begin executing the code there. When it reaches the end of the function, the execution returns to the line that called the function and continues moving through the code as before.</p><p>Since this program calls <code class="literal">hello()</code> three times, the code in the <code class="literal">hello()</code> function is executed three times. When you run this program, the output looks like this:</p><a id="pro_id00084"/><pre class="programlisting">Howdy!
Howdy!!!
Hello there.
Howdy!
Howdy!!!
Hello there.
Howdy!
Howdy!!!
Hello there.</pre><p>A major purpose of functions is to group code that gets executed multiple times. Without a function defined, you would have to copy and paste this code each time, and the program would look like this:</p><a id="pro_id00085"/><pre class="programlisting">print('Howdy!')
print('Howdy!!!')
print('Hello there.')
print('Howdy!')
print('Howdy!!!')
print('Hello there.')
print('Howdy!')
print('Howdy!!!')
print('Hello there.')</pre><p>In general, you always want to avoid duplicating code, because if you ever decide to update the code—if, for example, you find a bug you need to fix—you’ll have to remember to change the code everywhere you copied it.</p><p>As you get more programming experience, you’ll often find yourself <span class="emphasis"><em>deduplicating</em></span> code, which means getting rid of duplicated or copy-and-pasted code. Deduplication makes your programs shorter, easier to read, and easier to update.</p><div class="sect1" title="def Statements with Parameters"><div class="titlepage"><div><div><h1 class="title"><a id="def_statements_with_parameters"/>def Statements with Parameters</h1></div></div></div><p><a id="iddle1092" class="indexterm"/><a id="iddle1303" class="indexterm"/><a id="iddle1573" class="indexterm"/><a id="iddle1576" class="indexterm"/><a id="iddle1581" class="indexterm"/><a id="iddle1582" class="indexterm"/><a id="iddle2056" class="indexterm"/><a id="iddle2345" class="indexterm"/>When you call the <code class="literal">print()</code> or <code class="literal">len()</code> function, you pass in values, called <span class="emphasis"><em>arguments</em></span> in this context, by typing them between the parentheses. You can also define your own functions that accept arguments. Type this example into the file editor and save it as <span class="emphasis"><em>helloFunc2.py</em></span>:</p><a id="pro_id00086"/><pre class="programlisting">➊ def hello(name):
➋     print('Hello ' + name)

➌ hello('Alice')
  hello('Bob')</pre><p>When you run this program, the output looks like this:</p><a id="pro_id00087"/><pre class="programlisting">Hello Alice
Hello Bob</pre><p>The definition of the <code class="literal">hello()</code> function in this program has a parameter called <code class="literal">name</code> ➊. A <span class="emphasis"><em>parameter</em></span> is a variable that an argument is stored in when a function is called. The first time the <code class="literal">hello()</code> function is called, it’s with the argument <code class="literal">'Alice'</code> ➌. The program execution enters the function, and the variable <code class="literal">name</code> is automatically set to <code class="literal">'Alice'</code>, which is what gets printed by the <code class="literal">print()</code> statement ➋.</p><p>One special thing to note about parameters is that the value stored in a parameter is forgotten when the function returns. For example, if you added <code class="literal">print(name)</code> after <code class="literal">hello('Bob')</code> in the previous program, the program would give you a <code class="literal">NameError</code> because there is no variable named <code class="literal">name</code>. This variable was destroyed after the function call <code class="literal">hello('Bob')</code> had returned, so <code class="literal">print(name)</code> would refer to a <code class="literal">name</code> variable that does not exist.</p><p>This is similar to how a program’s variables are forgotten when the program terminates. I’ll talk more about why that happens later in the chapter, when I discuss what a function’s local scope is.</p></div><div class="sect1" title="Return Values and return Statements"><div class="titlepage"><div><div><h1 class="title"><a id="return_values_and_return_statements"/>Return Values and return Statements</h1></div></div></div><p>When you call the <code class="literal">len()</code> function and pass it an argument such as <code class="literal">'Hello'</code>, the function call evaluates to the integer value <code class="literal">5</code>, which is the length of the string you passed it. In general, the value that a function call evaluates to is called the <span class="emphasis"><em>return value</em></span> of the function.</p><p>When creating a function using the <code class="literal">def</code> statement, you can specify what the return value should be with a <code class="literal">return</code> statement. A <code class="literal">return</code> statement consists of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">return</code> keyword</p></li><li class="listitem"><p>The value or expression that the function should return</p></li></ul></div><p>When an expression is used with a <code class="literal">return</code> statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on what number it is passed as an argument. Type this code into the file editor and save it as <span class="emphasis"><em>magic8Ball.py</em></span>:</p><a id="pro_id00088"/><pre class="programlisting">➊ import random
➋ def getAnswer(answerNumber):
➌     if answerNumber == 1:
           return 'It is certain'
       elif answerNumber == 2:
           return 'It is decidedly so'
       elif answerNumber == 3:
           return 'Yes'
       elif answerNumber == 4:
           return 'Reply hazy try again'
       elif answerNumber == 5:
           return 'Ask again later'
       elif answerNumber == 6:
           return 'Concentrate and ask again'
       elif answerNumber == 7:
           return 'My reply is no'
       elif answerNumber == 8:
           return 'Outlook not so good'
       elif answerNumber == 9:
           return 'Very doubtful'

➍ r = random.randint(1, 9)
➎ fortune = getAnswer(r)
➏ print(fortune)</pre><p>When this program starts, Python first imports the <code class="literal">random</code> module ➊. Then the <code class="literal">getAnswer()</code> function is defined ➋. Because the function is being defined (and not called), the execution skips over the code in it. Next, the <code class="literal">random.randint()</code> function is called with two arguments, <code class="literal">1</code> and <code class="literal">9</code> ➍. It evaluates to a random integer between <code class="literal">1</code> and <code class="literal">9</code> (including <code class="literal">1</code> and <code class="literal">9</code> themselves), and this value is stored in a variable named <code class="literal">r</code>.</p><p>The <code class="literal">getAnswer()</code> function is called with <code class="literal">r</code> as the argument ➎. The program execution moves to the top of the <code class="literal">getAnswer()</code> function ➌, and the value <code class="literal">r</code> is stored in a parameter named <code class="literal">answerNumber</code>. Then, depending on this value in <code class="literal">answerNumber</code>, the function returns one of many possible string values. The program execution returns to the line at the bottom of the program that originally called <code class="literal">getAnswer()</code> ➎. The returned string is assigned to a variable named <code class="literal">fortune</code>, which then gets passed to a <code class="literal">print()</code> call ➏ and is printed to the screen.</p><p><a id="iddle1093" class="indexterm"/><a id="iddle1266" class="indexterm"/><a id="iddle1578" class="indexterm"/><a id="iddle1579" class="indexterm"/><a id="iddle1791" class="indexterm"/><a id="iddle2006" class="indexterm"/><a id="iddle2639" class="indexterm"/>Note that since you can pass return values as an argument to another function call, you could shorten these three lines:</p><a id="pro_id00089"/><pre class="programlisting">r = random.randint(1, 9)
fortune = getAnswer(r)
print(fortune)</pre><p>to this single equivalent line:</p><a id="pro_id00090"/><pre class="programlisting">print(getAnswer(random.randint(1, 9)))</pre><p>Remember, expressions are composed of values and operators. A function call can be used in an expression because it evaluates to its return value.</p></div><div class="sect1" title="The None Value"><div class="titlepage"><div><div><h1 class="title"><a id="none_value"/>The None Value</h1></div></div></div><p>In Python there is a value called <code class="literal">None</code>, which represents the absence of a value. <code class="literal">None</code> is the only value of the <code class="literal">NoneType</code> data type. (Other programming languages might call this value <code class="literal">null</code>, <code class="literal">nil</code>, or <code class="literal">undefined</code>.) Just like the Boolean <code class="literal">True</code> and <code class="literal">False</code> values, <code class="literal">None</code> must be typed with a capital <span class="emphasis"><em>N</em></span>.</p><p>This value-without-a-value can be helpful when you need to store something that won’t be confused for a real value in a variable. One place where <code class="literal">None</code> is used is as the return value of <code class="literal">print()</code>. The <code class="literal">print()</code> function displays text on the screen, but it doesn’t need to return anything in the same way <code class="literal">len()</code> or <code class="literal">input()</code> does. But since all function calls need to evaluate to a return value, <code class="literal">print()</code> returns <code class="literal">None</code>. To see this in action, enter the following into the interactive shell:</p><a id="pro_id00091"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>spam = print('Hello!')</strong></span>
Hello!
&gt;&gt;&gt; <span class="strong"><strong>None == spam</strong></span>
True</pre><p>Behind the scenes, Python adds <code class="literal">return None</code> to the end of any function definition with no <code class="literal">return</code> statement. This is similar to how a <code class="literal">while</code> or <code class="literal">for</code> loop implicitly ends with a <code class="literal">continue</code> statement. Also, if you use a <code class="literal">return</code> statement without a value (that is, just the <code class="literal">return</code> keyword by itself), then <code class="literal">None</code> is returned.</p></div><div class="sect1" title="Keyword Arguments and print()"><div class="titlepage"><div><div><h1 class="title"><a id="keyword_arguments_and_printleft_parenthe"/>Keyword Arguments and print()</h1></div></div></div><p>Most arguments are identified by their position in the function call. For example, <code class="literal">random.randint(1, 10)</code> is different from <code class="literal">random.randint(10, 1)</code>. The function call <code class="literal">random.randint(1, 10)</code> will return a random integer between <code class="literal">1</code> and <code class="literal">10</code>, because the first argument is the low end of the range and the second argument is the high end (while <code class="literal">random.randint(10, 1)</code> causes an error).</p><p><a id="iddle2152" class="indexterm"/>However, <span class="emphasis"><em>keyword arguments</em></span> are identified by the keyword put before them in the function call. Keyword arguments are often used for optional parameters. For example, the <code class="literal">print()</code> function has the optional parameters <code class="literal">end</code> and <code class="literal">sep</code> to specify what should be printed at the end of its arguments and between its arguments (separating them), respectively.</p><p>If you ran the following program:</p><a id="pro_id00092"/><pre class="programlisting">print('Hello')
print('World')</pre><p>the output would look like this:</p><a id="pro_id00093"/><pre class="programlisting">Hello
World</pre><p>The two strings appear on separate lines because the <code class="literal">print()</code> function automatically adds a newline character to the end of the string it is passed. However, you can set the <code class="literal">end</code> keyword argument to change this to a different string. For example, if the program were this:</p><a id="pro_id00094"/><pre class="programlisting">print('Hello', end='')
print('World')</pre><p>the output would look like this:</p><a id="pro_id00095"/><pre class="programlisting">HelloWorld</pre><p>The output is printed on a single line because there is no longer a new-line printed after <code class="literal">'Hello'</code>. Instead, the blank string is printed. This is useful if you need to disable the newline that gets added to the end of every <code class="literal">print()</code> function call.</p><p>Similarly, when you pass multiple string values to <code class="literal">print()</code>, the function will automatically separate them with a single space. Enter the following into the interactive shell:</p><a id="pro_id00096"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>print('cats', 'dogs', 'mice')</strong></span>
cats dogs mice</pre><p>But you could replace the default separating string by passing the <code class="literal">sep</code> keyword argument. Enter the following into the interactive shell:</p><a id="pro_id00097"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>print('cats', 'dogs', 'mice', sep=',')</strong></span>
cats,dogs,mice</pre><p>You can add keyword arguments to the functions you write as well, but first you’ll have to learn about the list and dictionary data types in the next two chapters. For now, just know that some functions have optional keyword arguments that can be specified when the function is called.</p></div><div class="sect1" title="Local and Global Scope"><div class="titlepage"><div><div><h1 class="title"><a id="local_and_global_scope"/>Local and Global Scope</h1></div></div></div><p><a id="iddle1863" class="indexterm"/><a id="iddle2173" class="indexterm"/><a id="iddle2376" class="indexterm"/><a id="iddle2637" class="indexterm"/>Parameters and variables that are assigned in a called function are said to exist in that function’s <span class="emphasis"><em>local scope</em></span>. Variables that are assigned outside all functions are said to exist in the <span class="emphasis"><em>global scope</em></span>. A variable that exists in a local scope is called a <span class="emphasis"><em>local variable</em></span>, while a variable that exists in the global scope is called a <span class="emphasis"><em>global variable</em></span>. A variable must be one or the other; it cannot be both local and global.</p><p>Think of a <span class="emphasis"><em>scope</em></span> as a container for variables. When a scope is destroyed, all the values stored in the scope’s variables are forgotten. There is only one global scope, and it is created when your program begins. When your program terminates, the global scope is destroyed, and all its variables are forgotten. Otherwise, the next time you ran your program, the variables would remember their values from the last time you ran it.</p><p>A local scope is created whenever a function is called. Any variables assigned in this function exist within the local scope. When the function returns, the local scope is destroyed, and these variables are forgotten. The next time you call this function, the local variables will not remember the values stored in them from the last time the function was called.</p><p>Scopes matter for several reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Code in the global scope cannot use any local variables.</p></li><li class="listitem"><p>However, a local scope can access global variables.</p></li><li class="listitem"><p>Code in a function’s local scope cannot use variables in any other local scope.</p></li><li class="listitem"><p>You can use the same name for different variables if they are in different scopes. That is, there can be a local variable named <code class="literal">spam</code> and a global variable also named <code class="literal">spam</code>.</p></li></ul></div><p>The reason Python has different scopes instead of just making everything a global variable is so that when variables are modified by the code in a particular call to a function, the function interacts with the rest of the program only through its parameters and the return value. This narrows down the list code lines that may be causing a bug. If your program contained nothing but global variables and had a bug because of a variable being set to a bad value, then it would be hard to track down where this bad value was set. It could have been set from anywhere in the program—and your program could be hundreds or thousands of lines long! But if the bug is because of a local variable with a bad value, you know that only the code in that one function could have set it incorrectly.</p><p>While using global variables in small programs is fine, it is a bad habit to rely on global variables as your programs get larger and larger.</p><div class="sect2" title="Local Variables Cannot Be Used in the Global Scope"><div class="titlepage"><div><div><h2 class="title"><a id="local_variables_cannot_be_used_in_the_gl"/>Local Variables Cannot Be Used in the Global Scope</h2></div></div></div><p>Consider this program, which will cause an error when you run it:</p><a id="pro_id00098"/><pre class="programlisting">def spam():
    eggs = 31337
spam()
print(eggs)</pre><p>If you run this program, the output will look like this:</p><a id="pro_id00099"/><pre class="programlisting">Traceback (most recent call last):
  File "C:/test3784.py", line 4, in &lt;module&gt;
    print(eggs)
NameError: name 'eggs' is not defined</pre><p>The error happens because the <code class="literal">eggs</code> variable exists only in the local scope created when <code class="literal">spam()</code> is called. Once the program execution returns from <code class="literal">spam</code>, that local scope is destroyed, and there is no longer a variable named <code class="literal">eggs</code>. So when your program tries to run <code class="literal">print(eggs)</code>, Python gives you an error saying that <code class="literal">eggs</code> is not defined. This makes sense if you think about it; when the program execution is in the global scope, no local scopes exist, so there can’t be any local variables. This is why only global variables can be used in the global scope.</p></div><div class="sect2" title="Local Scopes Cannot Use Variables in Other Local Scopes"><div class="titlepage"><div><div><h2 class="title"><a id="local_scopes_cannot_use_variables_in_oth"/>Local Scopes Cannot Use Variables in Other Local Scopes</h2></div></div></div><p>A new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:</p><a id="pro_id00100"/><pre class="programlisting">  def spam():
➊    eggs = 99
➋    bacon()
➌    print(eggs)

  def bacon():
      ham = 101
➍    eggs = 0

➎ spam()</pre><p>When the program starts, the <code class="literal">spam()</code> function is called ➎, and a local scope is created. The local variable <code class="literal">eggs</code> ➊ is set to <code class="literal">99</code>. Then the <code class="literal">bacon()</code> function is called ➋, and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable <code class="literal">ham</code> is set to <code class="literal">101</code>, and a local variable <code class="literal">eggs</code>—which is different from the one in <code class="literal">spam()</code>’s local scope—is also created ➍ and set to <code class="literal">0</code>.</p><p>When <code class="literal">bacon()</code> returns, the local scope for that call is destroyed. The program execution continues in the <code class="literal">spam()</code> function to print the value of <code class="literal">eggs</code> ➌, and since the local scope for the call to <code class="literal">spam()</code> still exists here, the <code class="literal">eggs</code> variable is set to <code class="literal">99</code>. This is what the program prints.</p><p>The upshot is that local variables in one function are completely separate from the local variables in another function.</p></div><div class="sect2" title="Global Variables Can Be Read from a Local Scope"><div class="titlepage"><div><div><h2 class="title"><a id="global_variables_can_be_read_from_a_loca"/>Global Variables Can Be Read from a Local Scope</h2></div></div></div><p>Consider the following program:</p><a id="pro_id00101"/><pre class="programlisting">def spam():
    print(eggs)
eggs = 42
spam()
print(eggs)</pre><p>Since there is no parameter named <code class="literal">eggs</code> or any code that assigns <code class="literal">eggs</code> a value in the <code class="literal">spam()</code> function, when <code class="literal">eggs</code> is used in <code class="literal">spam()</code>, Python considers it a reference to the global variable <code class="literal">eggs</code>. This is why <code class="literal">42</code> is printed when the previous program is run.</p></div><div class="sect2" title="Local and Global Variables with the Same Name"><div class="titlepage"><div><div><h2 class="title"><a id="local_and_global_variables_with_the_same"/>Local and Global Variables with the Same Name</h2></div></div></div><p>To simplify your life, avoid using local variables that have the same name as a global variable or another local variable. But technically, it’s perfectly legal to do so in Python. To see what happens, type the following code into the file editor and save it as <span class="emphasis"><em>sameName.py</em></span>:</p><a id="pro_id00102"/><pre class="programlisting">   def spam():
➊     eggs = 'spam local'
       print(eggs) # prints 'spam local'
   def bacon():

➋     eggs = 'bacon local'
       print(eggs) # prints 'bacon local'
       spam()
       print(eggs) # prints 'bacon local'

➌ eggs = 'global'
   bacon()
   print(eggs) # prints 'global'</pre><p>When you run this program, it outputs the following:</p><a id="pro_id00103"/><pre class="programlisting">bacon local
spam local
bacon local
global</pre><p>There are actually three different variables in this program, but confusingly they are all named <code class="literal">eggs</code>. The variables are as follows:</p><p>➊ A variable named <code class="literal">eggs</code> that exists in a local scope when <code class="literal">spam()</code> is called.</p><p>➋ A variable named <code class="literal">eggs</code> that exists in a local scope when <code class="literal">bacon()</code> is called.</p><p>➌ A variable named <code class="literal">eggs</code> that exists in the global scope.</p><p><a id="iddle1605" class="indexterm"/><a id="iddle2171" class="indexterm"/><a id="iddle2375" class="indexterm"/><a id="iddle2635" class="indexterm"/>Since these three separate variables all have the same name, it can be confusing to keep track of which one is being used at any given time. This is why you should avoid using the same variable name in different scopes.</p></div></div><div class="sect1" title="The global Statement"><div class="titlepage"><div><div><h1 class="title"><a id="global_statement"/>The global Statement</h1></div></div></div><p>If you need to modify a global variable from within a function, use the <code class="literal">global</code> statement. If you have a line such as <code class="literal">global eggs</code> at the top of a function, it tells Python, “In this function, <code class="literal">eggs</code> refers to the global variable, so don’t create a local variable with this name.” For example, type the following code into the file editor and save it as <span class="emphasis"><em>sameName2.py</em></span>:</p><a id="pro_id00104"/><pre class="programlisting">  def spam():
➊    global eggs
➋    eggs = 'spam'

  eggs = 'global'
  spam()
  print(eggs)</pre><p>When you run this program, the final <code class="literal">print()</code> call will output this:</p><a id="pro_id00105"/><pre class="programlisting">spam</pre><p>Because <code class="literal">eggs</code> is declared <code class="literal">global</code> at the top of <code class="literal">spam()</code> ➊, when <code class="literal">eggs</code> is set to <code class="literal">'spam'</code> ➋, this assignment is done to the globally scoped <code class="literal">eggs</code>. No local <code class="literal">eggs</code> variable is created.</p><p>There are four rules to tell whether a variable is in a local scope or global scope:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If a variable is being used in the global scope (that is, outside of all functions), then it is always a global variable.</p></li><li class="listitem"><p>If there is a <code class="literal">global</code> statement for that variable in a function, it is a global variable.</p></li><li class="listitem"><p>Otherwise, if the variable is used in an assignment statement in the function, it is a local variable.</p></li><li class="listitem"><p>But if the variable is not used in an assignment statement, it is a global variable.</p></li></ol></div><p>To get a better feel for these rules, here’s an example program. Type the following code into the file editor and save it as <span class="emphasis"><em>sameName3.py</em></span>:</p><a id="pro_id00106"/><pre class="programlisting">  def spam():
➊  global eggs
    eggs = 'spam' # this is the global

  def bacon():
➋  eggs = 'bacon' # this is a local
  def ham():
➌  print(eggs) # this is the global

  eggs = 42 # this is the global
  spam()
  print(eggs)</pre><p>In the <code class="literal">spam()</code> function, <code class="literal">eggs</code> is the global <code class="literal">eggs</code> variable, because there’s a <code class="literal">global</code> statement for <code class="literal">eggs</code> at the beginning of the function ➊. In <code class="literal">bacon()</code>, <code class="literal">eggs</code> is a local variable, because there’s an assignment statement for it in that function ➋. In <code class="literal">ham()</code> ➌, <code class="literal">eggs</code> is the global variable, because there is no assignment statement or <code class="literal">global</code> statement for it in that function. If you run <span class="emphasis"><em>sameName3.py</em></span>, the output will look like this:</p><a id="pro_id00107"/><pre class="programlisting">spam</pre><p>In a function, a variable will either always be global or always be local. There’s no way that the code in a function can use a local variable named <code class="literal">eggs</code> and then later in that same function use the global <code class="literal">eggs</code> variable.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note01"/>Note</h3><p><span class="emphasis"><em>If you ever want to modify the value stored in a global variable from in a function, you must use a <code class="literal">global</code> statement on that variable.</em></span></p></div><p>If you try to use a local variable in a function before you assign a value to it, as in the following program, Python will give you an error. To see this, type the following into the file editor and save it as <span class="emphasis"><em>sameName4.py</em></span>:</p><a id="pro_id00108"/><pre class="programlisting">  def spam():
      print(eggs) # ERROR!
➊    eggs = 'spam local'

➋ eggs = 'global'
   spam()</pre><p>If you run the previous program, it produces an error message.</p><a id="pro_id00109"/><pre class="programlisting">Traceback (most recent call last):
  File "C:/test3784.py", line 6, in &lt;module&gt;
    spam()
  File "C:/test3784.py", line 2, in spam
    print(eggs) # ERROR!
UnboundLocalError: local variable 'eggs' referenced before assignment</pre><p>This error happens because Python sees that there is an assignment statement for <code class="literal">eggs</code> in the <code class="literal">spam()</code> function ➊ and therefore considers <code class="literal">eggs</code> to be local. But because <code class="literal">print(eggs)</code> is executed before <code class="literal">eggs</code> is assigned anything, the local variable <code class="literal">eggs</code> doesn’t exist. Python will <span class="emphasis"><em>not</em></span> fall back to using the global <code class="literal">eggs</code> variable ➋.</p><div class="sidebar"><a id="functions_as_quotation_markblack_boxesqu"/><p class="title">Functions as “Black Boxes”</p><p><a id="iddle1450" class="indexterm"/><a id="iddle1574" class="indexterm"/><a id="iddle1577" class="indexterm"/><a id="iddle2168" class="indexterm"/><a id="iddle2170" class="indexterm"/>Often, all you need to know about a function are its inputs (the parameters) and output value; you don’t always have to burden yourself with how the function’s code actually works. When you think about functions in this high-level way, it’s common to say that you’re treating the function as a “black box.”</p><p>This idea is fundamental to modern programming. Later chapters in this book will show you several modules with functions that were written by other people. While you can take a peek at the source code if you’re curious, you don’t need to know how these functions work in order to use them. And because writing functions without global variables is encouraged, you usually don’t have to worry about the function’s code interacting with the rest of your program.</p></div></div><div class="sect1" title="Exception Handling"><div class="titlepage"><div><div><h1 class="title"><a id="exception_handling"/>Exception Handling</h1></div></div></div><p>Right now, getting an error, or <span class="emphasis"><em>exception</em></span>, in your Python program means the entire program will crash. You don’t want this to happen in real-world programs. Instead, you want the program to detect errors, handle them, and then continue to run.</p><p>For example, consider the following program, which has a “divide-by-zero” error. Open a new file editor window and enter the following code, saving it as <span class="emphasis"><em>zeroDivide.py</em></span>:</p><a id="pro_id00110"/><pre class="programlisting">def spam(divideBy):
    return 42 / divideBy

print(spam(2))
print(spam(12))
print(spam(0))
print(spam(1))</pre><p>We’ve defined a function called <code class="literal">spam</code>, given it a parameter, and then printed the value of that function with various parameters to see what happens. This is the output you get when you run the previous code:</p><a id="pro_id00111"/><pre class="programlisting">21.0
3.5
Traceback (most recent call last):
  File "C:/zeroDivide.py", line 6, in &lt;module&gt;
    print(spam(0))
  File "C:/zeroDivide.py", line 2, in spam
    return 42 / divideBy
ZeroDivisionError: division by zero</pre><p>A <code class="literal">ZeroDivisionError</code> happens whenever you try to divide a number by zero. From the line number given in the error message, you know that the <code class="literal">return</code> statement in <code class="literal">spam()</code> is causing an error.</p><p>Errors can be handled with <code class="literal">try</code> and <code class="literal">except</code> statements. The code that could potentially have an error is put in a <code class="literal">try</code> clause. The program execution moves to the start of a following <code class="literal">except</code> clause if an error happens.</p><p>You can put the previous divide-by-zero code in a <code class="literal">try</code> clause and have an <code class="literal">except</code> clause contain code to handle what happens when this error occurs.</p><a id="pro_id00112"/><pre class="programlisting">def spam(divideBy):
    try:
        return 42 / divideBy
    except ZeroDivisionError:
        print('Error: Invalid argument.')

print(spam(2))
print(spam(12))
print(spam(0))
print(spam(1))</pre><p>When code in a <code class="literal">try</code> clause causes an error, the program execution immediately moves to the code in the <code class="literal">except</code> clause. After running that code, the execution continues as normal. The output of the previous program is as follows:</p><a id="pro_id00113"/><pre class="programlisting">21.0
3.5
Error: Invalid argument.
None
42.0</pre><p>Note that any errors that occur in function calls in a <code class="literal">try</code> block will also be caught. Consider the following program, which instead has the <code class="literal">spam()</code> calls in the <code class="literal">try</code> block:</p><a id="pro_id00114"/><pre class="programlisting">def spam(divideBy):
    return 42 / divideBy

try:
    print(spam(2))
    print(spam(12))
    print(spam(0))
    print(spam(1))
except ZeroDivisionError:
    print('Error: Invalid argument.')</pre><p>When this program is run, the output looks like this:</p><a id="pro_id00115"/><pre class="programlisting">21.0
3.5
Error: Invalid argument.</pre><p><a id="iddle1626" class="indexterm"/>The reason <code class="literal">print(spam(1))</code> is never executed is because once the execution jumps to the code in the <code class="literal">except</code> clause, it does not return to the <code class="literal">try</code> clause. Instead, it just continues moving down as normal.</p></div><div class="sect1" title="A Short Program: Guess the Number"><div class="titlepage"><div><div><h1 class="title"><a id="short_program_guess_the_number"/>A Short Program: Guess the Number</h1></div></div></div><p>The toy examples I’ve show you so far are useful for introducing basic concepts, but now let’s see how everything you’ve learned comes together in a more complete program. In this section, I’ll show you a simple “guess the number” game. When you run this program, the output will look something like this:</p><a id="pro_id00116"/><pre class="programlisting">I am thinking of a number between 1 and 20.
Take a guess.
<span class="strong"><strong>10</strong></span>
Your guess is too low.
Take a guess.
<span class="strong"><strong>15</strong></span>
Your guess is too low.
Take a guess.
<span class="strong"><strong>17</strong></span>
Your guess is too high.
Take a guess.
<span class="strong"><strong>16</strong></span>
Good job! You guessed my number in 4 guesses!</pre><p>Type the following source code into the file editor, and save the file as <span class="emphasis"><em>guessTheNumber.py</em></span>:</p><a id="pro_id00117"/><pre class="programlisting"># This is a guess the number game.
import random
secretNumber = random.randint(1, 20)
print('I am thinking of a number between 1 and 20.')

# Ask the player to guess 6 times.
for guessesTaken in range(1, 7):
    print('Take a guess.')
    guess = int(input())

    if guess &lt; secretNumber:
        print('Your guess is too low.')
    elif guess &gt; secretNumber:
        print('Your guess is too high.')
    else:
        break    # This condition is the correct guess!

if guess == secretNumber:
    print('Good job! You guessed my number in ' + str(guessesTaken) + ' guesses!')
else:
    print('Nope. The number I was thinking of was ' + str(secretNumber))</pre><p>Let’s look at this code line by line, starting at the top.</p><a id="pro_id00118"/><pre class="programlisting"># This is a guess the number game.
import random
secretNumber = random.randint(1, 20)</pre><p>First, a comment at the top of the code explains what the program does. Then, the program imports the <code class="literal">random</code> module so that it can use the <code class="literal">random.randint()</code> function to generate a number for the user to guess. The return value, a random integer between 1 and 20, is stored in the variable <code class="literal">secretNumber</code>.</p><a id="pro_id00119"/><pre class="programlisting">print('I am thinking of a number between 1 and 20.')

# Ask the player to guess 6 times.
for guessesTaken in range(1, 7):
    print('Take a guess.')
    guess = int(input())</pre><p>The program tells the player that it has come up with a secret number and will give the player six chances to guess it. The code that lets the player enter a guess and checks that guess is in a <code class="literal">for</code> loop that will loop at most six times. The first thing that happens in the loop is that the player types in a guess. Since <code class="literal">input()</code> returns a string, its return value is passed straight into <code class="literal">int()</code>, which translates the string into an integer value. This gets stored in a variable named <code class="literal">guess</code>.</p><a id="pro_id00120"/><pre class="programlisting">if guess &lt; secretNumber:
    print('Your guess is too low.')
elif guess &gt; secretNumber:
    print('Your guess is too high.')</pre><p>These few lines of code check to see whether the guess is less than or greater than the secret number. In either case, a hint is printed to the screen.</p><a id="pro_id00121"/><pre class="programlisting">else:
    break    # This condition is the correct guess!</pre><p>If the guess is neither higher nor lower than the secret number, then it must be equal to the secret number, in which case you want the program execution to break out of the <code class="literal">for</code> loop.</p><a id="pro_id00122"/><pre class="programlisting">if guess == secretNumber:
    print('Good job! You guessed my number in ' + str(guessesTaken) + ' guesses!')
else:
    print('Nope. The number I was thinking of was ' + str(secretNumber))</pre><p>After the <code class="literal">for</code> loop, the previous <code class="literal">if...else</code> statement checks whether the player has correctly guessed the number and prints an appropriate message to the screen. In both cases, the program displays a variable that contains an integer value (<code class="literal">guessesTaken</code> and <code class="literal">secretNumber</code>). Since it must concatenate these integer values to strings, it passes these variables to the <code class="literal">str()</code> function, which returns the string value form of these integers. Now these strings can be concatenated with the <code class="literal">+</code> operators before finally being passed to the <code class="literal">print()</code> function call.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00007"/>Summary</h1></div></div></div><p>Functions are the primary way to compartmentalize your code into logical groups. Since the variables in functions exist in their own local scopes, the code in one function cannot directly affect the values of variables in other functions. This limits what code could be changing the values of your variables, which can be helpful when it comes to debugging your code.</p><p>Functions are a great tool to help you organize your code. You can think of them as black boxes: They have inputs in the form of parameters and outputs in the form of return values, and the code in them doesn’t affect variables in other functions.</p><p>In previous chapters, a single error could cause your programs to crash. In this chapter, you learned about <code class="literal">try</code> and <code class="literal">except</code> statements, which can run code when an error has been detected. This can make your programs more resilient to common error cases.</p></div><div class="sect1" title="Practice Questions"><div class="titlepage"><div><div><h1 class="title"><a id="practice_questions-id00008"/>Practice Questions</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch03qa1"/><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe1"/><a id="ch03qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. Why are functions advantageous to have in your programs?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe2"/><a id="ch03qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. When does the code in a function execute: when the function is defined or when the function is called?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe3"/><a id="ch03qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. What statement creates a function?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe4"/><a id="ch03qa1q4"/><p>Q:</p></td><td align="left" valign="top"><p>4. What is the difference between a function and a function call?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe5"/><a id="ch03qa1q5"/><p>Q:</p></td><td align="left" valign="top"><p>5. How many global scopes are there in a Python program? How many local scopes?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe6"/><a id="ch03qa1q6"/><p>Q:</p></td><td align="left" valign="top"><p>6. What happens to variables in a local scope when the function call returns?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe7"/><a id="ch03qa1q7"/><p>Q:</p></td><td align="left" valign="top"><p>7. What is a return value? Can a return value be part of an expression?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe8"/><a id="ch03qa1q8"/><p>Q:</p></td><td align="left" valign="top"><p>8. If a function does not have a return statement, what is the return value of a call to that function?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe9"/><a id="ch03qa1q9"/><p>Q:</p></td><td align="left" valign="top"><p>9. How can you force a variable in a function to refer to the global variable?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe10"/><a id="ch03qa1q10"/><p>Q:</p></td><td align="left" valign="top"><p>10. What is the data type of <code class="literal">None</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe11"/><a id="ch03qa1q11"/><p>Q:</p></td><td align="left" valign="top"><p>11. What does the <code class="literal">import areallyourpetsnamederic</code> statement do?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe12"/><a id="ch03qa1q12"/><p>Q:</p></td><td align="left" valign="top"><p>12. If you had a function named <code class="literal">bacon()</code> in a module named <code class="literal">spam</code>, how would you call it after importing <code class="literal">spam</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe13"/><a id="ch03qa1q13"/><p>Q:</p></td><td align="left" valign="top"><p>13. How can you prevent a program from crashing when it gets an error?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe14"/><a id="ch03qa1q14"/><p>Q:</p></td><td align="left" valign="top"><p>14. What goes in the <code class="literal">try</code> clause? What goes in the <code class="literal">except</code> clause?</p></td></tr></tbody></table></div></div><div class="sect1" title="Practice Projects"><div class="titlepage"><div><div><h1 class="title"><a id="practice_projects-id00009"/>Practice Projects</h1></div></div></div><p>For practice, write programs to do the following tasks.</p><div class="sect2" title="The Collatz Sequence"><div class="titlepage"><div><div><h2 class="title"><a id="collatz_sequence"/>The Collatz Sequence</h2></div></div></div><p>Write a function named <code class="literal">collatz()</code> that has one parameter named <code class="literal">number</code>. If <code class="literal">number</code> is even, then <code class="literal">collatz()</code> should print <code class="literal">number // 2</code> and return this value. If <code class="literal">number</code> is odd, then <code class="literal">collatz()</code> should print and return <code class="literal">3 * number + 1</code>.</p><p>Then write a program that lets the user type in an integer and that keeps calling <code class="literal">collatz()</code> on that number until the function returns the value <code class="literal">1</code>. (Amazingly enough, this sequence actually works for any integer—sooner or later, using this sequence, you’ll arrive at 1! Even mathematicians aren’t sure why. Your program is exploring what’s called the <span class="emphasis"><em>Collatz sequence</em></span>, sometimes called “the simplest impossible math problem.”)</p><p>Remember to convert the return value from <code class="literal">input()</code> to an integer with the <code class="literal">int()</code> function; otherwise, it will be a string value.</p><p>Hint: An integer <code class="literal">number</code> is even if <code class="literal">number % 2 == 0</code>, and it’s odd if <code class="literal">number % 2 == 1</code>.</p><p>The output of this program could look something like this:</p><a id="pro_id00123"/><pre class="programlisting">Enter number:
3
10
5
16
8
4
2
1</pre></div><div class="sect2" title="Input Validation"><div class="titlepage"><div><div><h2 class="title"><a id="input_validation"/>Input Validation</h2></div></div></div><p>Add <code class="literal">try</code> and <code class="literal">except</code> statements to the previous project to detect whether the user types in a noninteger string. Normally, the <code class="literal">int()</code> function will raise a <code class="literal">ValueError</code> error if it is passed a noninteger string, as in <code class="literal">int('puppy')</code>. In the <code class="literal">except</code> clause, print a message to the user saying they must enter an integer.</p></div></div></div></body></html>
