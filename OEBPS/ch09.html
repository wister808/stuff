<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. Organizing Files</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 9. Organizing Files"><div class="titlepage"><div><div><h1 class="title"><a id="organizing_files"/>Chapter 9. Organizing Files</h1></div></div></div><p>In the previous chapter, you learned how to create and write to new files in Python. Your programs can also organize preexisting files on the hard drive. Maybe you’ve had the experience of going through a folder full of dozens, hundreds, or even thousands of files and copying, renaming, moving, or compressing them all by hand. Or consider tasks such as these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Making copies of all PDF files (and <span class="emphasis"><em>only</em></span> the PDF files) in every sub-folder of a folder</p></li><li class="listitem"><p>Removing the leading zeros in the filenames for every file in a folder of hundreds of files named <span class="emphasis"><em>spam001.txt</em></span>, <span class="emphasis"><em>spam002.txt</em></span>, <span class="emphasis"><em>spam003.txt</em></span>, and so on</p></li><li class="listitem"><p>Compressing the contents of several folders into one ZIP file (which could be a simple backup system)</p></li></ul></div><p><a id="iddle1221" class="indexterm"/><a id="iddle1223" class="indexterm"/><a id="iddle1323" class="indexterm"/><a id="iddle1497" class="indexterm"/><a id="iddle1534" class="indexterm"/>All this boring stuff is just begging to be automated in Python. By programming your computer to do these tasks, you can transform it into a quick-working file clerk who never makes mistakes.</p><p>As you begin working with files, you may find it helpful to be able to quickly see what the extension (.<span class="emphasis"><em>txt</em></span>, .<span class="emphasis"><em>pdf</em></span>, .<span class="emphasis"><em>jpg</em></span>, and so on) of a file is. With OS X and Linux, your file browser most likely shows extensions automatically. With Windows, file extensions may be hidden by default. To show extensions, go to <span class="strong"><strong>Start</strong></span>▸ <span class="strong"><strong>Control Panel</strong></span>▸<span class="strong"><strong>Appearance and Personalization</strong></span>▸<span class="strong"><strong>Folder Options</strong></span>. On the View tab, under Advanced Settings, uncheck the <span class="strong"><strong>Hide extensions for known file types</strong></span> checkbox.</p><div class="sect1" title="The shutil Module"><div class="titlepage"><div><div><h1 class="title"><a id="shutil_module"/>The shutil Module</h1></div></div></div><p>The <code class="literal">shutil</code> (or shell utilities) module has functions to let you copy, move, rename, and delete files in your Python programs. To use the <code class="literal">shutil</code> functions, you will first need to use <code class="literal">import shutil</code>.</p><div class="sect2" title="Copying Files and Folders"><div class="titlepage"><div><div><h2 class="title"><a id="copying_files_and_folders"/>Copying Files and Folders</h2></div></div></div><p>The <code class="literal">shutil</code> module provides functions for copying files, as well as entire folders.</p><p>Calling <code class="literal">shutil.copy(</code><span class="emphasis"><em><code class="literal">source, destination</code></em></span><code class="literal">)</code> will copy the file at the path <span class="emphasis"><em><code class="literal">source</code></em></span> to the folder at the path <span class="emphasis"><em><code class="literal">destination</code></em></span>. (Both <span class="emphasis"><em><code class="literal">source</code></em></span> and <span class="emphasis"><em><code class="literal">destination</code></em></span> are strings.) If <span class="emphasis"><em><code class="literal">destination</code></em></span> is a filename, it will be used as the new name of the copied file. This function returns a string of the path of the copied file.</p><p>Enter the following into the interactive shell to see how <code class="literal">shutil.copy()</code> works:</p><a id="pro_id00358"/><pre class="programlisting">   &gt;&gt;&gt; <span class="strong"><strong>import shutil, os</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>os.chdir('C:\\')</strong></span>
➊ &gt;&gt;&gt; <span class="strong"><strong>shutil.copy('C:\\spam.txt', 'C:\\delicious')</strong></span>
   'C:\\delicious\\spam.txt'
➋ &gt;&gt;&gt; <span class="strong"><strong>shutil.copy('eggs.txt', 'C:\\delicious\\eggs2.txt')</strong></span>
   'C:\\delicious\\eggs2.txt'</pre><p>The first <code class="literal">shutil.copy()</code> call copies the file at <span class="emphasis"><em>C:\spam.txt</em></span> to the folder <span class="emphasis"><em>C:\delicious</em></span>. The return value is the path of the newly copied file. Note that since a folder was specified as the destination ➊, the original <span class="emphasis"><em>spam.txt</em></span> filename is used for the new, copied file’s filename. The second <code class="literal">shutil.copy()</code> call ➋ also copies the file at <span class="emphasis"><em>C:\eggs.txt</em></span> to the folder <span class="emphasis"><em>C:\delicious</em></span> but gives the copied file the name <span class="emphasis"><em>eggs2.txt</em></span>.</p><p>While <code class="literal">shutil.copy()</code> will copy a single file, <code class="literal">shutil.copytree()</code> will copy an entire folder and every folder and file contained in it. Calling <code class="literal">shutil.copytree(</code><span class="emphasis"><em><code class="literal">source, destination</code></em></span><code class="literal">)</code> will copy the folder at the path <span class="emphasis"><em><code class="literal">source</code></em></span>, along with all of its files and subfolders, to the folder at the path <span class="emphasis"><em><code class="literal">destination</code></em></span>. The <span class="emphasis"><em><code class="literal">source</code></em></span> and <span class="emphasis"><em><code class="literal">destination</code></em></span> parameters are both strings. The function returns a string of the path of the copied folder.</p><p><a id="iddle1329" class="indexterm"/><a id="iddle1336" class="indexterm"/><a id="iddle1499" class="indexterm"/><a id="iddle1500" class="indexterm"/><a id="iddle1540" class="indexterm"/><a id="iddle1547" class="indexterm"/><a id="iddle1967" class="indexterm"/><a id="iddle1975" class="indexterm"/><a id="iddle2333" class="indexterm"/><a id="iddle2427" class="indexterm"/><a id="iddle2428" class="indexterm"/>Enter the following into the interactive shell:</p><a id="pro_id00359"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import shutil, os</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>os.chdir('C:\\')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>shutil.copytree('C:\\bacon', 'C:\\bacon_backup')</strong></span>
'C:\\bacon_backup'</pre><p>The <code class="literal">shutil.copytree()</code> call creates a new folder named <span class="emphasis"><em>bacon_backup</em></span> with the same content as the original <span class="emphasis"><em>bacon</em></span> folder. You have now safely backed up your precious, precious bacon.</p></div><div class="sect2" title="Moving and Renaming Files and Folders"><div class="titlepage"><div><div><h2 class="title"><a id="moving_and_renaming_files_and_folders"/>Moving and Renaming Files and Folders</h2></div></div></div><p>Calling <code class="literal">shutil.move(</code><span class="emphasis"><em><code class="literal">source, destination</code></em></span><code class="literal">)</code> will move the file or folder at the path <span class="emphasis"><em><code class="literal">source</code></em></span> to the path <span class="emphasis"><em><code class="literal">destination</code></em></span> and will return a string of the absolute path of the new location.</p><p>If <span class="emphasis"><em><code class="literal">destination</code></em></span> points to a folder, the <span class="emphasis"><em><code class="literal">source</code></em></span> file gets moved into <span class="emphasis"><em><code class="literal">destination</code></em></span> and keeps its current filename. For example, enter the following into the interactive shell:</p><a id="pro_id00360"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import shutil</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>shutil.move('C:\\bacon.txt', 'C:\\eggs')</strong></span>
'C:\\eggs\\bacon.txt'</pre><p>Assuming a folder named <span class="emphasis"><em>eggs</em></span> already exists in the <span class="emphasis"><em>C:\</em></span> directory, this <code class="literal">shutil.move()</code> calls says, “Move <span class="emphasis"><em>C:\bacon.txt</em></span> into the folder <span class="emphasis"><em>C:\eggs</em></span>.”</p><p>If there had been a <span class="emphasis"><em>bacon.txt</em></span> file already in <span class="emphasis"><em>C:\eggs</em></span>, it would have been overwritten. Since it’s easy to accidentally overwrite files in this way, you should take some care when using <code class="literal">move()</code>.</p><p>The <span class="emphasis"><em><code class="literal">destination</code></em></span> path can also specify a filename. In the following example, the <span class="emphasis"><em><code class="literal">source</code></em></span> file is moved <span class="emphasis"><em>and</em></span> renamed.</p><a id="pro_id00361"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>shutil.move('C:\\bacon.txt', 'C:\\eggs\\new_bacon.txt')</strong></span>
'C:\\eggs\\new_bacon.txt'</pre><p>This line says, “Move <span class="emphasis"><em>C:\bacon.txt</em></span> into the folder <span class="emphasis"><em>C:\eggs</em></span>, and while you’re at it, rename that <span class="emphasis"><em>bacon.txt</em></span> file to <span class="emphasis"><em>new_bacon.txt</em></span>.”</p><p>Both of the previous examples worked under the assumption that there was a folder <span class="emphasis"><em>eggs</em></span> in the <span class="emphasis"><em>C:\</em></span> directory. But if there is no <span class="emphasis"><em>eggs</em></span> folder, then <code class="literal">move()</code> will rename <span class="emphasis"><em>bacon.txt</em></span> to a file named <span class="emphasis"><em>eggs</em></span>.</p><a id="pro_id00362"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>shutil.move('C:\\bacon.txt', 'C:\\eggs')</strong></span>
'C:\\eggs'</pre><p>Here, <code class="literal">move()</code> can’t find a folder named <span class="emphasis"><em>eggs</em></span> in the <span class="emphasis"><em>C:\</em></span> directory and so assumes that <span class="emphasis"><em><code class="literal">destination</code></em></span> must be specifying a filename, not a folder. So the <span class="emphasis"><em>bacon.txt</em></span> text file is renamed to <span class="emphasis"><em>eggs</em></span> (a text file without the <span class="emphasis"><em>.txt</em></span> file extension)—probably not what you wanted! This can be a tough-to-spot bug in <a id="iddle1306" class="indexterm"/><a id="iddle1327" class="indexterm"/><a id="iddle1498" class="indexterm"/><a id="iddle1538" class="indexterm"/><a id="iddle2353" class="indexterm"/><a id="iddle2354" class="indexterm"/><a id="iddle2426" class="indexterm"/><a id="iddle2623" class="indexterm"/>your programs since the <code class="literal">move()</code> call can happily do something that might be quite different from what you were expecting. This is yet another reason to be careful when using <code class="literal">move()</code>.</p><p>Finally, the folders that make up the destination must already exist, or else Python will throw an exception. Enter the following into the interactive shell:</p><a id="pro_id00363"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>shutil.move('spam.txt', 'c:\\does_not_exist\\eggs\\ham')</strong></span>
Traceback (most recent call last):
  File "C:\Python34\lib\shutil.py", line 521, in move
    os.rename(src, real_dst)
FileNotFoundError: [WinError 3] The system cannot find the path specified:
'spam.txt' -&gt; 'c:\\does_not_exist\\eggs\\ham'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "&lt;pyshell#29&gt;", line 1, in &lt;module&gt;
    shutil.move('spam.txt', 'c:\\does_not_exist\\eggs\\ham')
  File "C:\Python34\lib\shutil.py", line 533, in move
    copy2(src, real_dst)
  File "C:\Python34\lib\shutil.py", line 244, in copy2
    copyfile(src, dst, follow_symlinks=follow_symlinks)
  File "C:\Python34\lib\shutil.py", line 108, in copyfile
    with open(dst, 'wb') as fdst:
FileNotFoundError: [Errno 2] No such file or directory: 'c:\\does_not_exist\\
eggs\\ham'</pre><p>Python looks for <span class="emphasis"><em>eggs</em></span> and <span class="emphasis"><em>ham</em></span> inside the directory <span class="emphasis"><em>does_not_exist</em></span>. It doesn’t find the nonexistent directory, so it can’t move <span class="emphasis"><em>spam.txt</em></span> to the path you specified.</p></div><div class="sect2" title="Permanently Deleting Files and Folders"><div class="titlepage"><div><div><h2 class="title"><a id="permanently_deleting_files_and_folders"/>Permanently Deleting Files and Folders</h2></div></div></div><p>You can delete a single file or a single empty folder with functions in the <code class="literal">os</code> module, whereas to delete a folder and all of its contents, you use the <code class="literal">shutil</code> module.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Calling <code class="literal">os.unlink(</code><span class="emphasis"><em><code class="literal">path</code></em></span><code class="literal">)</code> will delete the file at <span class="emphasis"><em><code class="literal">path</code></em></span>.</p></li><li class="listitem"><p>Calling <code class="literal">os.rmdir(</code><span class="emphasis"><em><code class="literal">path</code></em></span><code class="literal">)</code> will delete the folder at <span class="emphasis"><em><code class="literal">path</code></em></span>. This folder must be empty of any files or folders.</p></li><li class="listitem"><p>Calling <code class="literal">shutil.rmtree(</code><span class="emphasis"><em><code class="literal">path</code></em></span><code class="literal">)</code> will remove the folder at <span class="emphasis"><em><code class="literal">path</code></em></span>, and all files and folders it contains will also be deleted.</p></li></ul></div><p>Be careful when using these functions in your programs! It’s often a good idea to first run your program with these calls commented out and with <code class="literal">print()</code> calls added to show the files that would be deleted. Here is <a id="iddle1307" class="indexterm"/><a id="iddle1328" class="indexterm"/><a id="iddle1495" class="indexterm"/><a id="iddle1539" class="indexterm"/><a id="iddle2409" class="indexterm"/>a Python program that was intended to delete files that have the <span class="emphasis"><em>.txt</em></span> file extension but has a typo (highlighted in bold) that causes it to delete <span class="emphasis"><em>.rxt</em></span> files instead:</p><a id="pro_id00364"/><pre class="programlisting">import os
for filename in os.listdir():
    if filename.endswith('.<span class="strong"><strong>r</strong></span>xt'):
        os.unlink(filename)</pre><p>If you had any important files ending with <span class="emphasis"><em>.rxt</em></span>, they would have been accidentally, permanently deleted. Instead, you should have first run the program like this:</p><a id="pro_id00365"/><pre class="programlisting">import os
for filename in os.listdir():
    if filename.endswith('.rxt'):
        #os.unlink(filename)
        print(filename)</pre><p>Now the <code class="literal">os.unlink()</code> call is commented, so Python ignores it. Instead, you will print the filename of the file that would have been deleted. Running this version of the program first will show you that you’ve accidentally told the program to delete <span class="emphasis"><em>.rxt</em></span> files instead of <span class="emphasis"><em>.txt</em></span> files.</p><p>Once you are certain the program works as intended, delete the <code class="literal">print(filename)</code> line and uncomment the <code class="literal">os.unlink(filename)</code> line. Then run the program again to actually delete the files.</p></div><div class="sect2" title="Safe Deletes with the send2trash Module"><div class="titlepage"><div><div><h2 class="title"><a id="safe_deletes_with_the_send2trash_module"/>Safe Deletes with the send2trash Module</h2></div></div></div><p>Since Python’s built-in <code class="literal">shutil.rmtree()</code> function irreversibly deletes files and folders, it can be dangerous to use. A much better way to delete files and folders is with the third-party <code class="literal">send2trash</code> module. You can install this module by running <code class="literal">pip install send2trash</code> from a Terminal window. (See Appendix A for a more in-depth explanation of how to install third-party modules.)</p><p>Using <code class="literal">send2trash</code> is much safer than Python’s regular delete functions, because it will send folders and files to your computer’s trash or recycle bin instead of permanently deleting them. If a bug in your program deletes something with <code class="literal">send2trash</code> you didn’t intend to delete, you can later restore it from the recycle bin.</p><p>After you have installed <code class="literal">send2trash</code>, enter the following into the interactive shell:</p><a id="pro_id00366"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import send2trash</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>baconFile = open('bacon.txt', 'a') # creates the file</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>baconFile.write('Bacon is not a vegetable.')</strong></span>
25
&gt;&gt;&gt; <span class="strong"><strong>baconFile.close()</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>send2trash.send2trash('bacon.txt')</strong></span></pre><p><a id="iddle1337" class="indexterm"/><a id="iddle1501" class="indexterm"/><a id="iddle1548" class="indexterm"/><a id="iddle2650" class="indexterm"/>In general, you should always use the <code class="literal">send2trash.send2trash()</code> function to delete files and folders. But while sending files to the recycle bin lets you recover them later, it will not free up disk space like permanently deleting them does. If you want your program to free up disk space, use the <code class="literal">os</code> and <code class="literal">shutil</code> functions for deleting files and folders. Note that the <code class="literal">send2trash()</code> function can only send files to the recycle bin; it cannot pull files out of it.</p></div></div><div class="sect1" title="Walking a Directory Tree"><div class="titlepage"><div><div><h1 class="title"><a id="walking_a_directory_tree"/>Walking a Directory Tree</h1></div></div></div><p>Say you want to rename every file in some folder and also every file in every subfolder of that folder. That is, you want to walk through the directory tree, touching each file as you go. Writing a program to do this could get tricky; fortunately, Python provides a function to handle this process for you.</p><p>Let’s look at the <span class="emphasis"><em>C:\delicious</em></span> folder with its contents, shown in <a class="xref" href="ch09.html#example_folder_that_contains_three_folde" title="Figure 9-1. An example folder that contains three folders and four files">Figure 9-1</a>.</p><div class="figure"><a id="example_folder_that_contains_three_folde"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00038"/><img src="figs/web/09fig01.png.jpg" alt="An example folder that contains three folders and four files"/></div></div><p class="title">Figure 9-1. An example folder that contains three folders and four files</p></div><p>Here is an example program that uses the <code class="literal">os.walk()</code> function on the directory tree from <a class="xref" href="ch09.html#example_folder_that_contains_three_folde" title="Figure 9-1. An example folder that contains three folders and four files">Figure 9-1</a>:</p><a id="pro_id00367"/><pre class="programlisting">import os

for folderName, subfolders, filenames in os.walk('C:\\delicious'):
    print('The current folder is ' + folderName)

    for subfolder in subfolders:
        print('SUBFOLDER OF ' + folderName + ': ' + subfolder)
    for filename in filenames:
        print('FILE INSIDE ' + folderName + ': '+ filename)

    print('')</pre><p><a id="iddle1206" class="indexterm"/><a id="iddle1477" class="indexterm"/><a id="iddle2739" class="indexterm"/>The <code class="literal">os.walk()</code> function is passed a single string value: the path of a folder. You can use <code class="literal">os.walk()</code> in a <code class="literal">for</code> loop statement to walk a directory tree, much like how you can use the <code class="literal">range()</code> function to walk over a range of numbers. Unlike <code class="literal">range()</code>, the <code class="literal">os.walk()</code> function will return three values on each iteration through the loop:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A string of the current folder’s name</p></li><li class="listitem"><p>A list of strings of the folders in the current folder</p></li><li class="listitem"><p>A list of strings of the files in the current folder</p></li></ol></div><p>(By current folder, I mean the folder for the current iteration of the <code class="literal">for</code> loop. The current working directory of the program is <span class="emphasis"><em>not</em></span> changed by <code class="literal">os.walk()</code>.)</p><p>Just like you can choose the variable name <code class="literal">i</code> in the code <code class="literal">for i in range(10):</code>, you can also choose the variable names for the three values listed earlier. I usually use the names <code class="literal">foldername</code>, <code class="literal">subfolders</code>, and <code class="literal">filenames</code>.</p><p>When you run this program, it will output the following:</p><a id="pro_id00368"/><pre class="programlisting">The current folder is C:\delicious
SUBFOLDER OF C:\delicious: cats
SUBFOLDER OF C:\delicious: walnut
FILE INSIDE C:\delicious: spam.txt

The current folder is C:\delicious\cats
FILE INSIDE C:\delicious\cats: catnames.txt
FILE INSIDE C:\delicious\cats: zophie.jpg

The current folder is C:\delicious\walnut
SUBFOLDER OF C:\delicious\walnut: waffles

The current folder is C:\delicious\walnut\waffles
FILE INSIDE C:\delicious\walnut\waffles: butter.txt.</pre><p>Since <code class="literal">os.walk()</code> returns lists of strings for the <code class="literal">subfolder</code> and <code class="literal">filename</code> variables, you can use these lists in their own <code class="literal">for</code> loops. Replace the <code class="literal">print()</code> function calls with your own custom code. (Or if you don’t need one or both of them, remove the <code class="literal">for</code> loops.)</p></div><div class="sect1" title="Compressing Files with the zipfile Module"><div class="titlepage"><div><div><h1 class="title"><a id="compressing_files_with_the_zipfile_modul"/>Compressing Files with the zipfile Module</h1></div></div></div><p>You may be familiar with ZIP files (with the <span class="emphasis"><em>.zip</em></span> file extension), which can hold the compressed contents of many other files. Compressing a file reduces its size, which is useful when transferring it over the Internet. And <a id="iddle1207" class="indexterm"/><a id="iddle1478" class="indexterm"/><a id="iddle2001" class="indexterm"/><a id="iddle2290" class="indexterm"/><a id="iddle2740" class="indexterm"/><a id="iddle2741" class="indexterm"/><a id="iddle2742" class="indexterm"/>since a ZIP file can also contain multiple files and subfolders, it’s a handy way to package several files into one. This single file, called an <span class="emphasis"><em>archive file</em></span>, can then be, say, attached to an email.</p><p>Your Python programs can both create and open (or <span class="emphasis"><em>extract</em></span>) ZIP files using functions in the <code class="literal">zipfile</code> module. Say you have a ZIP file named <span class="emphasis"><em>example.zip</em></span> that has the contents shown in <a class="xref" href="ch09.html#contents_of_exampledotzip" title="Figure 9-2. The contents of example.zip">Figure 9-2</a>.</p><p>You can download this ZIP file from <span class="emphasis"><em><a class="ulink" href="http://nostarch.com/automatestuff/">http://nostarch.com/automatestuff/</a></em></span> or just follow along using a ZIP file already on your computer.</p><div class="figure"><a id="contents_of_exampledotzip"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00039"/><img src="figs/web/09fig02.png.jpg" alt="The contents of example.zip"/></div></div><p class="title">Figure 9-2. The contents of <span class="emphasis"><em>example.zip</em></span></p></div><div class="sect2" title="Reading ZIP Files"><div class="titlepage"><div><div><h2 class="title"><a id="reading_zip_files"/>Reading ZIP Files</h2></div></div></div><p>To read the contents of a ZIP file, first you must create a <code class="literal">ZipFile</code> object (note the capital letters <span class="emphasis"><em>Z</em></span> and <span class="emphasis"><em>F</em></span>). <code class="literal">ZipFile</code> objects are conceptually similar to the <code class="literal">File</code> objects you saw returned by the <code class="literal">open()</code> function in the previous chapter: They are values through which the program interacts with the file. To create a <code class="literal">ZipFile</code> object, call the <code class="literal">zipfile.ZipFile()</code> function, passing it a string of the <span class="emphasis"><em>.zip</em></span> file’s filename. Note that <code class="literal">zipfile</code> is the name of the Python module, and <code class="literal">ZipFile()</code> is the name of the function.</p><p>For example, enter the following into the interactive shell:</p><a id="pro_id00369"/><pre class="programlisting">   &gt;&gt;&gt; <span class="strong"><strong>import zipfile, os</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>os.chdir('C:\\')    # move to the folder with example.zip</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>exampleZip = zipfile.ZipFile('example.zip')</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>exampleZip.namelist()</strong></span>
   ['spam.txt', 'cats/', 'cats/catnames.txt', 'cats/zophie.jpg']
   &gt;&gt;&gt; <span class="strong"><strong>spamInfo = exampleZip.getinfo('spam.txt')</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>spamInfo.file_size</strong></span>
   13908
   &gt;&gt;&gt; <span class="strong"><strong>spamInfo.compress_size</strong></span>
   3828
➊ &gt;&gt;&gt; <span class="strong"><strong>'Compressed file is %sx smaller!' % (round(spamInfo.file_size / spamInfo</strong></span>
   <span class="strong"><strong>.compress_size, 2))</strong></span>
   'Compressed file is 3.63x smaller!'
   &gt;&gt;&gt; <span class="strong"><strong>exampleZip.close()</strong></span></pre><p>A <code class="literal">ZipFile</code> object has a <code class="literal">namelist()</code> method that returns a list of strings for all the files and folders contained in the ZIP file. These strings can be passed to the <code class="literal">getinfo() ZipFile</code> method to return a <code class="literal">ZipInfo</code> object about that particular file. <code class="literal">ZipInfo</code> objects have their own attributes, such as <code class="literal">file_size</code> and <code class="literal">compress_size</code> in bytes, which hold integers of the original file size and compressed file size, respectively. While a <code class="literal">ZipFile</code> object represents an entire archive file, a <code class="literal">ZipInfo</code> object holds useful information about a <span class="emphasis"><em>single file</em></span> in the archive.</p><p>The command at ➊ calculates how efficiently <span class="emphasis"><em>example.zip</em></span> is compressed by dividing the original file size by the compressed file size and prints this information using a string formatted with <code class="literal">%s</code>.</p></div><div class="sect2" title="Extracting from ZIP Files"><div class="titlepage"><div><div><h2 class="title"><a id="extracting_from_zip_files"/>Extracting from ZIP Files</h2></div></div></div><p><a id="iddle1204" class="indexterm"/><a id="iddle1205" class="indexterm"/><a id="iddle1464" class="indexterm"/><a id="iddle1465" class="indexterm"/><a id="iddle1466" class="indexterm"/><a id="iddle1475" class="indexterm"/><a id="iddle1476" class="indexterm"/><a id="iddle2736" class="indexterm"/><a id="iddle2737" class="indexterm"/>The <code class="literal">extractall()</code> method for <code class="literal">ZipFile</code> objects extracts all the files and folders from a ZIP file into the current working directory.</p><a id="pro_id00370"/><pre class="programlisting">   &gt;&gt;&gt; <span class="strong"><strong>import zipfile, os</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>os.chdir('C:\\')    # move to the folder with example.zip</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>exampleZip = zipfile.ZipFile('example.zip')</strong></span>
➊ &gt;&gt;&gt; <span class="strong"><strong>exampleZip.extractall()</strong></span>
   &gt;&gt;&gt; <span class="strong"><strong>exampleZip.close()</strong></span></pre><p>After running this code, the contents of <span class="emphasis"><em>example.zip</em></span> will be extracted to <span class="emphasis"><em>C:\</em></span>. Optionally, you can pass a folder name to <code class="literal">extractall()</code> to have it extract the files into a folder other than the current working directory. If the folder passed to the <code class="literal">extractall()</code> method does not exist, it will be created. For instance, if you replaced the call at ➊ with <code class="literal">exampleZip.extractall('C:\\ delicious')</code>, the code would extract the files from <span class="emphasis"><em>example.zip</em></span> into a newly created <span class="emphasis"><em>C:\delicious</em></span> folder.</p><p>The <code class="literal">extract()</code> method for <code class="literal">ZipFile</code> objects will extract a single file from the ZIP file. Continue the interactive shell example:</p><a id="pro_id00371"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>exampleZip.extract('spam.txt')</strong></span>
'C:\\spam.txt'
&gt;&gt;&gt; <span class="strong"><strong>exampleZip.extract('spam.txt', 'C:\\some\\new\\folders')</strong></span>
'C:\\some\\new\\folders\\spam.txt'
&gt;&gt;&gt; <span class="strong"><strong>exampleZip.close()</strong></span></pre><p>The string you pass to <code class="literal">extract()</code> must match one of the strings in the list returned by <code class="literal">namelist()</code>. Optionally, you can pass a second argument to <code class="literal">extract()</code> to extract the file into a folder other than the current working directory. If this second argument is a folder that doesn’t yet exist, Python will create the folder. The value that <code class="literal">extract()</code> returns is the absolute path to which the file was extracted.</p></div><div class="sect2" title="Creating and Adding to ZIP Files"><div class="titlepage"><div><div><h2 class="title"><a id="creating_and_adding_to_zip_files"/>Creating and Adding to ZIP Files</h2></div></div></div><p>To create your own compressed ZIP files, you must open the <code class="literal">ZipFile</code> object in <span class="emphasis"><em>write mode</em></span> by passing <code class="literal">'w'</code> as the second argument. (This is similar to opening a text file in write mode by passing <code class="literal">'w'</code> to the <code class="literal">open()</code> function.)</p><p>When you pass a path to the <code class="literal">write()</code> method of a <code class="literal">ZipFile</code> object, Python will compress the file at that path and add it into the ZIP file. The <code class="literal">write()</code> method’s first argument is a string of the filename to add. The second argument is the <span class="emphasis"><em>compression type</em></span> parameter, which tells the computer what algorithm it should use to compress the files; you can always just set this value to <code class="literal">zipfile.ZIP_DEFLATED</code>. (This specifies the <span class="emphasis"><em>deflate</em></span> compression algorithm, which works well on all types of data.) Enter the following into the interactive shell:</p><a id="pro_id00372"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import zipfile</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>newZip = zipfile.ZipFile('new.zip', 'w')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>newZip.write('spam.txt', compress_type=zipfile.ZIP_DEFLATED)</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>newZip.close()</strong></span></pre><p><a id="iddle1493" class="indexterm"/><a id="iddle2195" class="indexterm"/><a id="iddle2334" class="indexterm"/><a id="iddle2335" class="indexterm"/><a id="iddle2337" class="indexterm"/>This code will create a new ZIP file named <span class="emphasis"><em>new.zip</em></span> that has the compressed contents of <span class="emphasis"><em>spam.txt</em></span>.</p><p>Keep in mind that, just as with writing to files, write mode will erase all existing contents of a ZIP file. If you want to simply add files to an existing ZIP file, pass <code class="literal">'a'</code> as the second argument to <code class="literal">zipfile.ZipFile()</code> to open the ZIP file in <span class="emphasis"><em>append mode</em></span>.</p></div></div><div class="sect1" title="Project: Renaming Files with American-Style Dates to European-Style Dates"><div class="titlepage"><div><div><h1 class="title"><a id="project_renaming_files_with_american-sty"/>Project: Renaming Files with American-Style Dates to European-Style Dates</h1></div></div></div><p>Say your boss emails you thousands of files with American-style dates (MM-DD-YYYY) in their names and needs them renamed to European-style dates (DD-MM-YYYY). This boring task could take all day to do by hand! Let’s write a program to do it instead.</p><p>Here’s what the program does:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It searches all the filenames in the current working directory for American-style dates.</p></li><li class="listitem"><p>When one is found, it renames the file with the month and day swapped to make it European-style.</p></li></ul></div><p>This means the code will need to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Create a regex that can identify the text pattern of American-style dates.</p></li><li class="listitem"><p>Call <code class="literal">os.listdir()</code> to find all the files in the working directory.</p></li><li class="listitem"><p>Loop over each filename, using the regex to check whether it has a date.</p></li><li class="listitem"><p>If it has a date, rename the file with <code class="literal">shutil.move()</code>.</p></li></ul></div><p>For this project, open a new file editor window and save your code as <span class="emphasis"><em>renameDates.py</em></span>.</p><div class="sect2" title="Step 1: Create a Regex for American-Style Dates"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_create_a_regex_for_american-style"/>Step 1: Create a Regex for American-Style Dates</h2></div></div></div><p>The first part of the program will need to import the necessary modules and create a regex that can identify MM-DD-YYYY dates. The to-do comments will remind you what’s left to write in this program. Typing them as <code class="literal">TODO</code> makes them easy to find using IDLE’s <span class="smaller">CTRL</span>-F find feature. Make your code look like the following:</p><a id="pro_id00373"/><pre class="programlisting">   #! python3
   # renameDates.py - Renames filenames with American MM-DD-YYYY date format
   # to European DD-MM-YYYY.

➊ import shutil, os, re

   # Create a regex that matches files with the American date format.
➋ datePattern = re.compile(r"""^(.*?) # all text before the date
       ((0|1)?\d)-                     # one or two digits for the month
       ((0|1|2|3)?\d)-                 # one or two digits for the day
       ((19|20)\d\d)                   # four digits for the year
       (.*?)$                          # all text after the date
➌     """, re.VERBOSE)

   # TODO: Loop over the files in the working directory.

   # TODO: Skip files without a date.

   # TODO: Get the different parts of the filename.

   # TODO: Form the European-style filename.

   # TODO: Get the full, absolute file paths.

   # TODO: Rename the files.</pre><p><a id="iddle2336" class="indexterm"/>From this chapter, you know the <code class="literal">shutil.move()</code> function can be used to rename files: Its arguments are the name of the file to rename and the new filename. Because this function exists in the <code class="literal">shutil</code> module, you must import that module ➊.</p><p>But before renaming the files, you need to identify which files you want to rename. Filenames with dates such as <span class="emphasis"><em>spam4-4-1984.txt</em></span> and <span class="emphasis"><em>01-03-2014eggs.zip</em></span> should be renamed, while filenames without dates such as <span class="emphasis"><em>littlebrother.epub</em></span> can be ignored.</p><p>You can use a regular expression to identify this pattern. After importing the <code class="literal">re</code> module at the top, call <code class="literal">re.compile()</code> to create a <code class="literal">Regex</code> object ➋. Passing <code class="literal">re.VERBOSE</code> for the second argument ➌ will allow whitespace and comments in the regex string to make it more readable.</p><p>The regular expression string begins with <code class="literal">^(.*?)</code> to match any text at the beginning of the filename that might come before the date. The <code class="literal">((0|1)?\d)</code> group matches the month. The first digit can be either <code class="literal">0</code> or <code class="literal">1</code>, so the regex matches <code class="literal">12</code> for December but also <code class="literal">02</code> for February. This digit is also optional so that the month can be <code class="literal">04</code> or <code class="literal">4</code> for April. The group for the day is <code class="literal">((0|1|2|3)?\d)</code> and follows similar logic; <code class="literal">3</code>, <code class="literal">03</code>, and <code class="literal">31</code> are all valid numbers for days. (Yes, this regex will accept some invalid dates such as <code class="literal">4-31-2014</code>, <code class="literal">2-29-2013</code>, and <code class="literal">0-15-2014</code>. Dates have a lot of thorny special cases that can be easy to miss. But for simplicity, the regex in this program works well enough.)</p><p>While 1885 is a valid year, you can just look for years in the 20th or 21st century. This will keep your program from accidentally matching nondate filenames with a date-like format, such as <span class="emphasis"><em>10-10-1000.txt</em></span>.</p><p>The <code class="literal">(.*?)$</code> part of the regex will match any text that comes after the date.</p></div><div class="sect2" title="Step 2: Identify the Date Parts from the Filenames"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_identify_the_date_parts_from_the"/>Step 2: Identify the Date Parts from the Filenames</h2></div></div></div><p>Next, the program will have to loop over the list of filename strings returned from <code class="literal">os.listdir()</code> and match them against the regex. Any files that do not have a date in them should be skipped. For filenames that have a date, the matched text will be stored in several variables. Fill in the first three <code class="literal">TODO</code>s in your program with the following code:</p><a id="pro_id00374"/><pre class="programlisting">   #! python3
   # renameDates.py - Renames filenames with American MM-DD-YYYY date format
   # to European DD-MM-YYYY.

   --<span class="emphasis"><em>snip</em></span>--

   <span class="strong"><strong># Loop over the files in the working directory.</strong></span>
   <span class="strong"><strong>for amerFilename in os.listdir('.'):</strong></span>
       <span class="strong"><strong>mo = datePattern.search(amerFilename)</strong></span>

       <span class="strong"><strong># Skip files without a date.</strong></span>
➊     <span class="strong"><strong>if mo == None:</strong></span>
➋         <span class="strong"><strong>continue</strong></span>

➌     <span class="strong"><strong># Get the different parts of the filename.</strong></span>
       <span class="strong"><strong>beforePart = mo.group(1)</strong></span>
       <span class="strong"><strong>monthPart  = mo.group(2)</strong></span>
       <span class="strong"><strong>dayPart    = mo.group(4)</strong></span>
       <span class="strong"><strong>yearPart   = mo.group(6)</strong></span>
       <span class="strong"><strong>afterPart  = mo.group(8)</strong></span>

   --<span class="emphasis"><em>snip</em></span>--</pre><p>If the <code class="literal">Match</code> object returned from the <code class="literal">search()</code> method is <code class="literal">None</code> ➊, then the filename in <code class="literal">amerFilename</code> does not match the regular expression. The <code class="literal">continue</code> statement ➋ will skip the rest of the loop and move on to the next filename.</p><p>Otherwise, the various strings matched in the regular expression groups are stored in variables named <code class="literal">beforePart</code>, <code class="literal">monthPart</code>, <code class="literal">dayPart</code>, <code class="literal">yearPart</code>, and <code class="literal">afterPart</code> ➌. The strings in these variables will be used to form the European-style filename in the next step.</p><p>To keep the group numbers straight, try reading the regex from the beginning and count up each time you encounter an opening parenthesis. Without thinking about the code, just write an outline of the regular expression. This can help you visualize the groups. For example:</p><a id="pro_id00375"/><pre class="programlisting">datePattern = re.compile(r"""^(<span class="strong"><strong>1</strong></span>) # all text before the date
    (<span class="strong"><strong>2</strong></span> (<span class="strong"><strong>3</strong></span>) )-                     # one or two digits for the month
    (<span class="strong"><strong>4</strong></span> (<span class="strong"><strong>5</strong></span>) )-                     # one or two digits for the day
    (<span class="strong"><strong>6</strong></span> (<span class="strong"><strong>7</strong></span>) )                      # four digits for the year
    (<span class="strong"><strong>8</strong></span>)$                          # all text after the date
    """, re.VERBOSE)</pre><p>Here, the numbers <span class="strong"><strong><code class="literal">1</code></strong></span> through <span class="strong"><strong><code class="literal">8</code></strong></span> represent the groups in the regular expression you wrote. Making an outline of the regular expression, with just the parentheses and group numbers, can give you a clearer understanding of your regex before you move on with the rest of the program.</p></div><div class="sect2" title="Step 3: Form the New Filename and Rename the Files"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_form_the_new_filename_and_rename"/>Step 3: Form the New Filename and Rename the Files</h2></div></div></div><p><a id="iddle1203" class="indexterm"/><a id="iddle1474" class="indexterm"/><a id="iddle1529" class="indexterm"/><a id="iddle2180" class="indexterm"/><a id="iddle2338" class="indexterm"/><a id="iddle2738" class="indexterm"/>As the final step, concatenate the strings in the variables made in the previous step with the European-style date: The date comes before the month. Fill in the three remaining <code class="literal">TODO</code>s in your program with the following code:</p><a id="pro_id00376"/><pre class="programlisting">   #! python3
   # renameDates.py - Renames filenames with American MM-DD-YYYY date format
   # to European DD-MM-YYYY.

   --<span class="emphasis"><em>snip</em></span>--

       <span class="strong"><strong># Form the European-style filename.</strong></span>
➊     <span class="strong"><strong>euroFilename = beforePart + dayPart + '-' + monthPart + '-' + yearPart +</strong></span>
                      <span class="strong"><strong>afterPart</strong></span>

       <span class="strong"><strong># Get the full, absolute file paths.</strong></span>
       <span class="strong"><strong>absWorkingDir = os.path.abspath('.')</strong></span>
       <span class="strong"><strong>amerFilename = os.path.join(absWorkingDir, amerFilename)</strong></span>
       <span class="strong"><strong>euroFilename = os.path.join(absWorkingDir, euroFilename)</strong></span>

       <span class="strong"><strong># Rename the files.</strong></span>
➋     <span class="strong"><strong>print('Renaming "%s" to "%s"...' % (amerFilename, euroFilename))</strong></span>
➌     <span class="strong"><strong>#shutil.move(amerFilename, euroFilename)   # uncomment after testing</strong></span></pre><p>Store the concatenated string in a variable named <code class="literal">euroFilename</code> ➊. Then, pass the original filename in <code class="literal">amerFilename</code> and the new <code class="literal">euroFilename</code> variable to the <code class="literal">shutil.move()</code> function to rename the file ➌.</p><p>This program has the <code class="literal">shutil.move()</code> call commented out and instead prints the filenames that will be renamed ➋. Running the program like this first can let you double-check that the files are renamed correctly. Then you can uncomment the <code class="literal">shutil.move()</code> call and run the program again to actually rename the files.</p></div><div class="sect2" title="Ideas for Similar Programs"><div class="titlepage"><div><div><h2 class="title"><a id="ideas_for_similar_programs-id00026"/>Ideas for Similar Programs</h2></div></div></div><p>There are many other reasons why you might want to rename a large number of files.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To add a prefix to the start of the filename, such as adding <span class="emphasis"><em>spam_</em></span> to rename <span class="emphasis"><em>eggs.txt</em></span> to <span class="emphasis"><em>spam_eggs.txt</em></span></p></li><li class="listitem"><p>To change filenames with European-style dates to American-style dates</p></li><li class="listitem"><p>To remove the zeros from files such as <span class="emphasis"><em>spam0042.txt</em></span></p></li></ul></div></div></div><div class="sect1" title="Project: Backing Up a Folder into a ZIP File"><div class="titlepage"><div><div><h1 class="title"><a id="project_backing_up_a_folder_into_a_zip_f"/>Project: Backing Up a Folder into a ZIP File</h1></div></div></div><p>Say you’re working on a project whose files you keep in a folder named <span class="emphasis"><em>C:\AlsPythonBook</em></span>. You’re worried about losing your work, so you’d like to create ZIP file “snapshots” of the entire folder. You’d like to keep different versions, so you want the ZIP file’s filename to increment each time it is made; for example, <span class="emphasis"><em>AlsPythonBook_1.zip</em></span>, <span class="emphasis"><em>AlsPythonBook_2.zip</em></span>, <a id="iddle1531" class="indexterm"/><span class="emphasis"><em>AlsPythonBook_3.zip</em></span>, and so on. You could do this by hand, but it is rather annoying, and you might accidentally misnumber the ZIP files’ names. It would be much simpler to run a program that does this boring task for you.</p><p>For this project, open a new file editor window and save it as <span class="emphasis"><em>backupToZip.py</em></span>.</p><div class="sect2" title="Step 1: Figure Out the ZIP File’s Name"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_figure_out_the_zip_fileapostrophe"/>Step 1: Figure Out the ZIP File’s Name</h2></div></div></div><p>The code for this program will be placed into a function named <code class="literal">backupToZip()</code>. This will make it easy to copy and paste the function into other Python programs that need this functionality. At the end of the program, the function will be called to perform the backup. Make your program look like this:</p><a id="pro_id00377"/><pre class="programlisting">   #! python3
   # backupToZip.py - Copies an entire folder and its contents into
   # a ZIP file whose filename increments.

➊ import zipfile, os

   def backupToZip(folder):
       # Backup the entire contents of "folder" into a ZIP file.
 
       folder = os.path.abspath(folder) # make sure folder is absolute
 
       # Figure out the filename this code should use based on
       # what files already exist.
➋     number = 1
➌     while True:
           zipFilename = os.path.basename(folder) + '_' + str(number) + '.zip'
           if not os.path.exists(zipFilename):
               break
           number = number + 1

➍     # TODO: Create the ZIP file.

       # TODO: Walk the entire folder tree and compress the files in each folder.
       print('Done.')

   backupToZip('C:\\delicious')</pre><p>Do the basics first: Add the shebang (<code class="literal">#!</code>) line, describe what the program does, and import the <code class="literal">zipfile</code> and <code class="literal">os</code> modules ➊.</p><p>Define a <code class="literal">backupToZip()</code> function that takes just one parameter, <code class="literal">folder</code>. This parameter is a string path to the folder whose contents should be backed up. The function will determine what filename to use for the ZIP file it will create; then the function will create the file, walk the <code class="literal">folder</code> folder, and add each of the subfolders and files to the ZIP file. Write <code class="literal">TODO</code> comments for these steps in the source code to remind yourself to do them later ➍.</p><p>The first part, naming the ZIP file, uses the base name of the absolute path of <code class="literal">folder</code>. If the folder being backed up is <span class="emphasis"><em>C:\delicious</em></span>, the ZIP file’s name should be <span class="emphasis"><em>delicious_N.zip</em></span>, where <span class="emphasis"><em>N</em></span> = 1 is the first time you run the program, <span class="emphasis"><em>N</em></span> = 2 is the second time, and so on.</p><p><a id="iddle1530" class="indexterm"/><a id="iddle1532" class="indexterm"/>You can determine what <span class="emphasis"><em>N</em></span> should be by checking whether <span class="emphasis"><em>delicious_1.zip</em></span> already exists, then checking whether <span class="emphasis"><em>delicious_2.zip</em></span> already exists, and so on. Use a variable named <code class="literal">number</code> for <span class="emphasis"><em>N</em></span> ➋, and keep incrementing it inside the loop that calls <code class="literal">os.path.exists()</code> to check whether the file exists ➌. The first nonexistent filename found will cause the loop to <code class="literal">break</code>, since it will have found the filename of the new zip.</p></div><div class="sect2" title="Step 2: Create the New ZIP File"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_create_the_new_zip_file"/>Step 2: Create the New ZIP File</h2></div></div></div><p>Next let’s create the ZIP file. Make your program look like the following:</p><a id="pro_id00378"/><pre class="programlisting">   #! python3
   # backupToZip.py - Copies an entire folder and its contents into
   # a ZIP file whose filename increments.

   --<span class="emphasis"><em>snip</em></span>--
       while True:
           zipFilename = os.path.basename(folder) + '_' + str(number) + '.zip'
           if not os.path.exists(zipFilename):
               break
           number = number + 1

       <span class="strong"><strong># Create the ZIP file.</strong></span>
       <span class="strong"><strong>print('Creating %s...' % (zipFilename))</strong></span>
➊     <span class="strong"><strong>backupZip = zipfile.ZipFile(zipFilename, 'w')</strong></span>

       # TODO: Walk the entire folder tree and compress the files in each folder.
       print('Done.')

   backupToZip('C:\\delicious')</pre><p>Now that the new ZIP file’s name is stored in the <code class="literal">zipFilename</code> variable, you can call <code class="literal">zipfile.ZipFile()</code> to actually create the ZIP file ➊. Be sure to pass <code class="literal">'w'</code> as the second argument so that the ZIP file is opened in write mode.</p></div><div class="sect2" title="Step 3: Walk the Directory Tree and Add to the ZIP File"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_walk_the_directory_tree_and_add_t"/>Step 3: Walk the Directory Tree and Add to the ZIP File</h2></div></div></div><p>Now you need to use the <code class="literal">os.walk()</code> function to do the work of listing every file in the folder and its subfolders. Make your program look like the following:</p><a id="pro_id00379"/><pre class="programlisting">   #! python3
   # backupToZip.py - Copies an entire folder and its contents into
   # a ZIP file whose filename increments.

   --<span class="emphasis"><em>snip</em></span>--

       <span class="strong"><strong># Walk the entire folder tree and compress the files in each folder.</strong></span>
➊     <span class="strong"><strong>for foldername, subfolders, filenames in os.walk(folder):</strong></span>
           <span class="strong"><strong>print('Adding files in %s...' % (foldername))</strong></span>
           <span class="strong"><strong># Add the current folder to the ZIP file.</strong></span>
➋         <span class="strong"><strong>backupZip.write(foldername)</strong></span>
           <span class="strong"><strong># Add all the files in this folder to the ZIP file.</strong></span>
➌         <span class="strong"><strong>for filename in filenames:</strong></span>
               <span class="strong"><strong>newBase / os.path.basename(folder) + '_'</strong></span>
               <span class="strong"><strong>if filename.startswith(newBase) and filename.endswith('.zip')</strong></span>
                   <span class="strong"><strong>continue   # don't backup the backup ZIP files</strong></span>
               <span class="strong"><strong>backupZip.write(os.path.join(foldername, filename))</strong></span>
       <span class="strong"><strong>backupZip.close()</strong></span>
       print('Done.')


   backupToZip('C:\\delicious')</pre><p>You can use <code class="literal">os.walk()</code> in a <code class="literal">for</code> loop ➊, and on each iteration it will return the iteration’s current folder name, the subfolders in that folder, and the filenames in that folder.</p><p>In the <code class="literal">for</code> loop, the folder is added to the ZIP file ➋. The nested <code class="literal">for</code> loop can go through each filename in the <code class="literal">filenames</code> list ➌. Each of these is added to the ZIP file, except for previously made backup ZIPs.</p><p>When you run this program, it will produce output that will look something like this:</p><a id="pro_id00380"/><pre class="programlisting">Creating delicious_1.zip...
Adding files in C:\delicious...
Adding files in C:\delicious\cats...
Adding files in C:\delicious\waffles...
Adding files in C:\delicious\walnut...
Adding files in C:\delicious\walnut\waffles...
Done.</pre><p>The second time you run it, it will put all the files in <span class="emphasis"><em>C:\delicious</em></span> into a ZIP file named <span class="emphasis"><em>delicious_2.zip</em></span>, and so on.</p></div><div class="sect2" title="Ideas for Similar Programs"><div class="titlepage"><div><div><h2 class="title"><a id="ideas_for_similar_programs-id00027"/>Ideas for Similar Programs</h2></div></div></div><p>You can walk a directory tree and add files to compressed ZIP archives in several other programs. For example, you can write programs that do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Walk a directory tree and archive just files with certain extensions, such as <span class="emphasis"><em>.txt</em></span> or <span class="emphasis"><em>.py</em></span>, and nothing else</p></li><li class="listitem"><p>Walk a directory tree and archive every file except the <span class="emphasis"><em>.txt</em></span> and <span class="emphasis"><em>.py</em></span> ones</p></li><li class="listitem"><p>Find the folder in a directory tree that has the greatest number of files or the folder that uses the most disk space</p></li></ul></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00028"/>Summary</h1></div></div></div><p>Even if you are an experienced computer user, you probably handle files manually with the mouse and keyboard. Modern file explorers make it easy to work with a few files. But sometimes you’ll need to perform a task that would take hours using your computer’s file explorer.</p><p>The <code class="literal">os</code> and <code class="literal">shutil</code> modules offer functions for copying, moving, renaming, and deleting files. When deleting files, you might want to use the <code class="literal">send2trash</code> module to move files to the recycle bin or trash rather than permanently deleting them. And when writing programs that handle files, it’s a good idea to comment out the code that does the actual copy/move/ rename/delete and add a <code class="literal">print()</code> call instead so you can run the program and verify exactly what it will do.</p><p>Often you will need to perform these operations not only on files in one folder but also on every folder in that folder, every folder in those folders, and so on. The <code class="literal">os.walk()</code> function handles this trek across the folders for you so that you can concentrate on what your program needs to do with the files in them.</p><p>The <code class="literal">zipfile</code> module gives you a way of compressing and extracting files in <span class="emphasis"><em>.zip</em></span> archives through Python. Combined with the file-handling functions of <code class="literal">os</code> and <code class="literal">shutil</code>, <code class="literal">zipfile</code> makes it easy to package up several files from anywhere on your hard drive. These <span class="emphasis"><em>.zip</em></span> files are much easier to upload to websites or send as email attachments than many separate files.</p><p>Previous chapters of this book have provided source code for you to copy. But when you write your own programs, they probably won’t come out perfectly the first time. The next chapter focuses on some Python modules that will help you analyze and debug your programs so that you can quickly get them working correctly.</p></div><div class="sect1" title="Practice Questions"><div class="titlepage"><div><div><h1 class="title"><a id="practice_questions-id00029"/>Practice Questions</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch09qa1"/><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch09qa1qe1"/><a id="ch09qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. What is the difference between <code class="literal">shutil.copy()</code> and <code class="literal">shutil.copytree()</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch09qa1qe2"/><a id="ch09qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. What function is used to rename files?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch09qa1qe3"/><a id="ch09qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. What is the difference between the delete functions in the <code class="literal">send2trash</code> and <code class="literal">shutil</code> modules?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch09qa1qe4"/><a id="ch09qa1q4"/><p>Q:</p></td><td align="left" valign="top"><p>4. <code class="literal">ZipFile</code> objects have a <code class="literal">close()</code> method just like <code class="literal">File</code> objects’ <code class="literal">close()</code> method. What <code class="literal">ZipFile</code> method is equivalent to <code class="literal">File</code> objects’ <code class="literal">open()</code> method?</p></td></tr></tbody></table></div></div><div class="sect1" title="Practice Projects"><div class="titlepage"><div><div><h1 class="title"><a id="practice_projects-id00030"/>Practice Projects</h1></div></div></div><p>For practice, write programs to do the following tasks.</p><div class="sect2" title="Selective Copy"><div class="titlepage"><div><div><h2 class="title"><a id="selective_copy"/>Selective Copy</h2></div></div></div><p>Write a program that walks through a folder tree and searches for files with a certain file extension (such as <span class="emphasis"><em>.pdf</em></span> or <span class="emphasis"><em>.jpg</em></span>). Copy these files from whatever location they are in to a new folder.</p></div><div class="sect2" title="Deleting Unneeded Files"><div class="titlepage"><div><div><h2 class="title"><a id="deleting_unneeded_files"/>Deleting Unneeded Files</h2></div></div></div><p>It’s not uncommon for a few unneeded but humongous files or folders to take up the bulk of the space on your hard drive. If you’re trying to free up room on your computer, you’ll get the most bang for your buck by deleting the most massive of the unwanted files. But first you have to find them.</p><p>Write a program that walks through a folder tree and searches for exceptionally large files or folders—say, ones that have a file size of more than 100MB. (Remember, to get a file’s size, you can use <code class="literal">os.path.getsize()</code> from the <code class="literal">os</code> module.) Print these files with their absolute path to the screen.</p></div><div class="sect2" title="Filling in the Gaps"><div class="titlepage"><div><div><h2 class="title"><a id="filling_in_the_gaps"/>Filling in the Gaps</h2></div></div></div><p>Write a program that finds all files with a given prefix, such as <span class="emphasis"><em>spam001.txt</em></span>, <span class="emphasis"><em>spam002.txt</em></span>, and so on, in a single folder and locates any gaps in the numbering (such as if there is a <span class="emphasis"><em>spam001.txt</em></span> and <span class="emphasis"><em>spam003.txt</em></span> but no <span class="emphasis"><em>spam002.txt</em></span>). Have the program rename all the later files to close this gap.</p><p>As an added challenge, write another program that can insert gaps into numbered files so that a new file can be added.</p></div></div></div></body></html>
