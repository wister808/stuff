<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 7. Pattern Matching with Regular Expressions</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 7. Pattern Matching with Regular Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="pattern_matching_with_regular_expression"/>Chapter 7. Pattern Matching with Regular Expressions</h1></div></div></div><p><a id="iddle2305" class="indexterm"/>You may be familiar with searching for text by pressing <span class="smaller">CTRL</span>-F and typing in the words you’re looking for. <span class="emphasis"><em>Regular expressions</em></span> go one step further: They allow you to specify a <span class="emphasis"><em>pattern</em></span> of text to search for. You may not know a business’s exact phone number, but if you live in the United States or Canada, you know it will be three digits, followed by a hyphen, and then four more digits (and optionally, a three-digit area code at the start). This is how you, as a human, know a phone number when you see it: 415-555-1234 is a phone number, but 4,155,551,234 is not.</p><p>Regular expressions are helpful, but not many non-programmers know about them even though most modern text editors and word processors, such as Microsoft Word or OpenOffice, have find and find-and-replace features that can search based on regular expressions. Regular expressions are huge time-savers, not just for software users but also for <a id="iddle2309" class="indexterm"/>programmers. In fact, tech writer Cory Doctorow argues that even before teaching programming, we should be teaching regular expressions:</p><div class="blockquote"><blockquote class="blockquote"><p>“Knowing [regular expressions] can mean the difference between solving a problem in 3 steps and solving it in 3,000 steps. When you’re a nerd, you forget that the problems you solve with a couple keystrokes can take other people days of tedious, error-prone work to slog through.”<sup>[<a id="ch07fn01" href="#ftn.ch07fn01" class="footnote">1</a>]</sup></p></blockquote></div><p>In this chapter, you’ll start by writing a program to find text patterns <span class="emphasis"><em>without</em></span> using regular expressions and then see how to use regular expressions to make the code much less bloated. I’ll show you basic matching with regular expressions and then move on to some more powerful features, such as string substitution and creating your own character classes. Finally, at the end of the chapter, you’ll write a program that can automatically extract phone numbers and email addresses from a block of text.</p><div class="sect1" title="Finding Patterns of Text Without Regular Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="finding_patterns_of_text_without_regular"/>Finding Patterns of Text Without Regular Expressions</h1></div></div></div><p>Say you want to find a phone number in a string. You know the pattern: three numbers, a hyphen, three numbers, a hyphen, and four numbers. Here’s an example: 415-555-4242.</p><p>Let’s use a function named <code class="literal">isPhoneNumber()</code> to check whether a string matches this pattern, returning either <code class="literal">True</code> or <code class="literal">False</code>. Open a new file editor window and enter the following code; then save the file as <span class="emphasis"><em>isPhoneNumber.py</em></span>:</p><a id="pro_id00272"/><pre class="programlisting">   def isPhoneNumber(text):
➊     if len(text) != 12:
           return False
       for i in range(0, 3):
➋         if not text[i].isdecimal():
               return False
➌     if text[3] != '-':
           return False
       for i in range(4, 7):
➍         if not text[i].isdecimal():
               return False
➎     if text[7] != '-':
           return False
       for i in range(8, 12):
➏         if not text[i].isdecimal():
               return False
➐     return True

   print('415-555-4242 is a phone number:')
   print(isPhoneNumber('415-555-4242'))
   print('Moshi moshi is a phone number:')
   print(isPhoneNumber('Moshi moshi'))</pre><p>When this program is run, the output looks like this:</p><a id="pro_id00273"/><pre class="programlisting">415-555-4242 is a phone number:
True
Moshi moshi is a phone number:
False</pre><p>The <code class="literal">isPhoneNumber()</code> function has code that does several checks to see whether the string in <code class="literal">text</code> is a valid phone number. If any of these checks fail, the function returns <code class="literal">False</code>. First the code checks that the string is exactly 12 characters ➊. Then it checks that the area code (that is, the first three characters in <code class="literal">text</code>) consists of only numeric characters ➋. The rest of the function checks that the string follows the pattern of a phone number: The number must have the first hyphen after the area code ➌, three more numeric characters ➍, then another hyphen ➎, and finally four more numbers ➏. If the program execution manages to get past all the checks, it returns <code class="literal">True</code> ➐.</p><p>Calling <code class="literal">isPhoneNumber()</code> with the argument <code class="literal">'415-555-4242'</code> will return <code class="literal">True</code>. Calling <code class="literal">isPhoneNumber()</code> with <code class="literal">'Moshi moshi'</code> will return <code class="literal">False</code>; the first test fails because <code class="literal">'Moshi moshi'</code> is not 12 characters long.</p><p>You would have to add even more code to find this pattern of text in a larger string. Replace the last four <code class="literal">print()</code> function calls in <span class="emphasis"><em>isPhoneNumber.py</em></span> with the following:</p><a id="pro_id00274"/><pre class="programlisting">   message = 'Call me at 415-555-1011 tomorrow. 415-555-9999 is my office.'
   for i in range(len(message)):
➊     chunk = message[i:i+12]
➋     if isPhoneNumber(chunk):
         print('Phone number found: ' + chunk)
   print('Done')</pre><p>When this program is run, the output will look like this:</p><a id="pro_id00275"/><pre class="programlisting">Phone number found: 415-555-1011
Phone number found: 415-555-9999
Done</pre><p>On each iteration of the <code class="literal">for</code> loop, a new chunk of 12 characters from <code class="literal">message</code> is assigned to the variable <code class="literal">chunk</code> ➊. For example, on the first iteration, <code class="literal">i</code> is <code class="literal">0</code>, and <code class="literal">chunk</code> is assigned <code class="literal">message[0:12]</code> (that is, the string <code class="literal">'Call me at 4'</code>). On the next iteration, <code class="literal">i</code> is <code class="literal">1</code>, and <code class="literal">chunk</code> is assigned <code class="literal">message[1:13]</code> (the string <code class="literal">'all me at 41'</code>).</p><p>You pass <code class="literal">chunk</code> to <code class="literal">isPhoneNumber()</code> to see whether it matches the phone number pattern ➋, and if so, you print the chunk.</p><p>Continue to loop through <code class="literal">message</code>, and eventually the 12 characters in <code class="literal">chunk</code> will be a phone number. The loop goes through the entire string, testing each 12-character piece and printing any <code class="literal">chunk</code> it finds that satisfies <code class="literal">isPhoneNumber()</code>. Once we’re done going through <code class="literal">message</code>, we print <code class="literal">Done</code>.</p><p><a id="iddle2299" class="indexterm"/><a id="iddle2304" class="indexterm"/><a id="iddle2321" class="indexterm"/><a id="iddle2630" class="indexterm"/>While the string in <code class="literal">message</code> is short in this example, it could be millions of characters long and the program would still run in less than a second. A similar program that finds phone numbers using regular expressions would also run in less than a second, but regular expressions make it quicker to write these programs.</p></div><div class="sect1" title="Finding Patterns of Text with Regular Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="finding_patterns_of_text_with_regular_ex"/>Finding Patterns of Text with Regular Expressions</h1></div></div></div><p>The previous phone number–finding program works, but it uses a lot of code to do something limited: The <code class="literal">isPhoneNumber()</code> function is 17 lines but can find only one pattern of phone numbers. What about a phone number formatted like 415.555.4242 or (415) 555-4242? What if the phone number had an extension, like 415-555-4242 x99? The <code class="literal">isPhoneNumber()</code> function would fail to validate them. You could add yet more code for these additional patterns, but there is an easier way.</p><p>Regular expressions, called <span class="emphasis"><em>regexes</em></span> for short, are descriptions for a pattern of text. For example, a <code class="literal">\d</code> in a regex stands for a digit character—that is, any single numeral 0 to 9. The regex <code class="literal">\d\d\d-\d\d\d-\d\d\d\d</code> is used by Python to match the same text the previous <code class="literal">isPhoneNumber()</code> function did: a string of three numbers, a hyphen, three more numbers, another hyphen, and four numbers. Any other string would not match the <code class="literal">\d\d\d-\d\d\d-\d\d \d\d</code> regex.</p><p>But regular expressions can be much more sophisticated. For example, adding a <code class="literal">3</code> in curly brackets (<code class="literal">{3}</code>) after a pattern is like saying, “Match this pattern three times.” So the slightly shorter regex <code class="literal">\d{3}-\d{3}-\d{4}</code> also matches the correct phone number format.</p><div class="sect2" title="Creating Regex Objects"><div class="titlepage"><div><div><h2 class="title"><a id="creating_regex_objects"/>Creating Regex Objects</h2></div></div></div><p>All the regex functions in Python are in the <code class="literal">re</code> module. Enter the following into the interactive shell to import this module:</p><a id="pro_id00276"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>import re</strong></span></pre><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p><span class="emphasis"><em>Most of the examples that follow in this chapter will require the <code class="literal">re</code> module, so remember to import it at the beginning of any script you write or any time you restart IDLE. Otherwise, you’ll get a <code class="literal">NameError: name 're' is not defined</code> error message.</em></span></p></div><p>Passing a string value representing your regular expression to <code class="literal">re.compile()</code> returns a <code class="literal">Regex</code> pattern object (or simply, a <code class="literal">Regex</code> object).</p><p>To create a <code class="literal">Regex</code> object that matches the phone number pattern, enter the following into the interactive shell. (Remember that <code class="literal">\d</code> means “a digit character” and <code class="literal">\d\d\d-\d\d\d-\d\d\d\d</code> is the regular expression for the correct phone number pattern.)</p><a id="pro_id00277"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')</strong></span></pre><p><a id="iddle1004" class="indexterm"/><a id="iddle1109" class="indexterm"/><a id="iddle1200" class="indexterm"/><a id="iddle1616" class="indexterm"/><a id="iddle1904" class="indexterm"/><a id="iddle2287" class="indexterm"/><a id="iddle2300" class="indexterm"/><a id="iddle2318" class="indexterm"/><a id="iddle2394" class="indexterm"/>Now the <code class="literal">phoneNumRegex</code> variable contains a <code class="literal">Regex</code> object.</p><div class="sidebar"><a id="passing_raw_strings_to_redotcompileleft"/><p class="title">Passing Raw Strings to re.compile( )</p><p>Remember that escape characters in Python use the backslash (\). The string value <code class="literal">'\n'</code> represents a single newline character, not a backslash followed by a lowercase <span class="emphasis"><em>n</em></span>. You need to enter the escape character <code class="literal">\\</code> to print a single backslash. So <code class="literal">'\\n'</code> is the string that represents a backslash followed by a lowercase <span class="emphasis"><em>n</em></span>. However, by putting an <code class="literal">r</code> before the first quote of the string value, you can mark the string as a <span class="emphasis"><em>raw string</em></span>, which does not escape characters.</p><p>Since regular expressions frequently use backslashes in them, it is convenient to pass raw strings to the <code class="literal">re.compile()</code> function instead of typing extra backslashes. Typing <code class="literal">r'\d\d\d-\d\d\d-\d\d\d\d'</code> is much easier than typing <code class="literal">'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d'</code>.</p></div></div><div class="sect2" title="Matching Regex Objects"><div class="titlepage"><div><div><h2 class="title"><a id="matching_regex_objects"/>Matching Regex Objects</h2></div></div></div><p>A <code class="literal">Regex</code> object’s <code class="literal">search()</code> method searches the string it is passed for any matches to the regex. The <code class="literal">search()</code> method will return <code class="literal">None</code> if the regex pattern is not found in the string. If the pattern <span class="emphasis"><em>is</em></span> found, the <code class="literal">search()</code> method returns a <code class="literal">Match</code> object. <code class="literal">Match</code> objects have a <code class="literal">group()</code> method that will return the actual matched text from the searched string. (I’ll explain groups shortly.) For example, enter the following into the interactive shell:</p><a id="pro_id00278"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo = phoneNumRegex.search('My number is 415-555-4242.')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>print('Phone number found: ' + mo.group())</strong></span>
Phone number found: 415-555-4242</pre><p>The <code class="literal">mo</code> variable name is just a generic name to use for <code class="literal">Match</code> objects. This example might seem complicated at first, but it is much shorter than the earlier <span class="emphasis"><em>isPhoneNumber.py</em></span> program and does the same thing.</p><p>Here, we pass our desired pattern to <code class="literal">re.compile()</code> and store the resulting <code class="literal">Regex</code> object in <code class="literal">phoneNumRegex</code>. Then we call <code class="literal">search()</code> on <code class="literal">phoneNumRegex</code> and pass <code class="literal">search()</code> the string we want to search for a match. The result of the search gets stored in the variable <code class="literal">mo</code>. In this example, we know that our pattern will be found in the string, so we know that a <code class="literal">Match</code> object will be returned. Knowing that <code class="literal">mo</code> contains a <code class="literal">Match</code> object and not the null value <code class="literal">None</code>, we can call <code class="literal">group()</code> on <code class="literal">mo</code> to return the match. Writing <code class="literal">mo.group()</code> inside our print statement displays the whole match, <code class="literal">415-555-4242</code>.</p></div><div class="sect2" title="Review of Regular Expression Matching"><div class="titlepage"><div><div><h2 class="title"><a id="review_of_regular_expression_matching"/>Review of Regular Expression Matching</h2></div></div></div><p><a id="iddle1045" class="indexterm"/><a id="iddle1201" class="indexterm"/><a id="iddle1617" class="indexterm"/><a id="iddle1624" class="indexterm"/><a id="iddle2058" class="indexterm"/><a id="iddle2314" class="indexterm"/>While there are several steps to using regular expressions in Python, each step is fairly simple.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Import the regex module with <code class="literal">import re</code>.</p></li><li class="listitem"><p>Create a <code class="literal">Regex</code> object with the <code class="literal">re.compile()</code> function. (Remember to use a raw string.)</p></li><li class="listitem"><p>Pass the string you want to search into the <code class="literal">Regex</code> object’s <code class="literal">search()</code> method. This returns a <code class="literal">Match</code> object.</p></li><li class="listitem"><p>Call the <code class="literal">Match</code> object’s <code class="literal">group()</code> method to return a string of the actual matched text.</p></li></ol></div><div class="note" title="Note"><h3 class="title"><a id="ch07note02"/>Note</h3><p><span class="emphasis"><em>While I encourage you to enter the example code into the interactive shell, you should also make use of web-based regular expression testers, which can show you exactly how a regex matches a piece of text that you enter. I recommend the tester at</em></span> <a class="ulink" href="http://regexpal.com/">http://regexpal.com/</a>.</p></div></div></div><div class="sect1" title="More Pattern Matching with Regular Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="more_pattern_matching_with_regular_expre"/>More Pattern Matching with Regular Expressions</h1></div></div></div><p>Now that you know the basic steps for creating and finding regular expression objects with Python, you’re ready to try some of their more powerful pattern-matching capabilities.</p><div class="sect2" title="Grouping with Parentheses"><div class="titlepage"><div><div><h2 class="title"><a id="grouping_with_parentheses"/>Grouping with Parentheses</h2></div></div></div><p>Say you want to separate the area code from the rest of the phone number. Adding parentheses will create <span class="emphasis"><em>groups</em></span> in the regex: <code class="literal">(\d\d\d)-(\d\d\d-\d\d\d\d)</code>. Then you can use the <code class="literal">group()</code> match object method to grab the matching text from just one group.</p><p>The first set of parentheses in a regex string will be group <code class="literal">1</code>. The second set will be group <code class="literal">2</code>. By passing the integer <code class="literal">1</code> or <code class="literal">2</code> to the <code class="literal">group()</code> match object method, you can grab different parts of the matched text. Passing <code class="literal">0</code> or nothing to the <code class="literal">group()</code> method will return the entire matched text. Enter the following into the interactive shell:</p><a id="pro_id00279"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo = phoneNumRegex.search('My number is 415-555-4242.')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo.group(1)</strong></span>
'415'
&gt;&gt;&gt; <span class="strong"><strong>mo.group(2)</strong></span>
'555-4242'
&gt;&gt;&gt; <span class="strong"><strong>mo.group(0)</strong></span>
'415-555-4242'
&gt;&gt;&gt; <span class="strong"><strong>mo.group()</strong></span>
'415-555-4242'</pre><p><a id="iddle1046" class="indexterm"/><a id="iddle1625" class="indexterm"/><a id="iddle2125" class="indexterm"/><a id="iddle2315" class="indexterm"/>If you would like to retrieve all the groups at once, use the <code class="literal">groups()</code> method—note the plural form for the name.</p><a id="pro_id00280"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>mo.groups()</strong></span>
('415', '555-4242')
&gt;&gt;&gt; <span class="strong"><strong>areaCode, mainNumber = mo.groups()</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>print(areaCode)</strong></span>
415
&gt;&gt;&gt; <span class="strong"><strong>print(mainNumber)</strong></span>
555-4242</pre><p>Since <code class="literal">mo.groups()</code> returns a tuple of multiple values, you can use the multiple-assignment trick to assign each value to a separate variable, as in the previous <code class="literal">areaCode, mainNumber = mo.groups()</code> line.</p><p>Parentheses have a special meaning in regular expressions, but what do you do if you need to match a parenthesis in your text? For instance, maybe the phone numbers you are trying to match have the area code set in parentheses. In this case, you need to escape the <code class="literal">(</code> and <code class="literal">)</code> characters with a backslash. Enter the following into the interactive shell:</p><a id="pro_id00281"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex = re.compile(r'(\(\d\d\d\)) (\d\d\d-\d\d\d\d)')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo = phoneNumRegex.search('My phone number is (415) 555-4242.')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo.group(1)</strong></span>
'(415)'
&gt;&gt;&gt; <span class="strong"><strong>mo.group(2)</strong></span>
'555-4242'</pre><p>The <code class="literal">\(</code> and <code class="literal">\)</code> escape characters in the raw string passed to <code class="literal">re.compile()</code> will match actual parenthesis characters.</p></div><div class="sect2" title="Matching Multiple Groups with the Pipe"><div class="titlepage"><div><div><h2 class="title"><a id="matching_multiple_groups_with_the_pipe"/>Matching Multiple Groups with the Pipe</h2></div></div></div><p>The <code class="literal">|</code> character is called a <span class="emphasis"><em>pipe</em></span>. You can use it anywhere you want to match one of many expressions. For example, the regular expression <code class="literal">r'Batman|Tina Fey'</code> will match either <code class="literal">'Batman'</code> or <code class="literal">'Tina Fey'</code>.</p><p>When <span class="emphasis"><em>both</em></span> Batman and Tina Fey occur in the searched string, the first occurrence of matching text will be returned as the <code class="literal">Match</code> object. Enter the following into the interactive shell:</p><a id="pro_id00282"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>heroRegex = re.compile (r'Batman|Tina Fey')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1 = heroRegex.search('Batman and Tina Fey.')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1.group()</strong></span>
'Batman'

&gt;&gt;&gt; <span class="strong"><strong>mo2 = heroRegex.search('Tina Fey and Batman.')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo2.group()</strong></span>
'Tina Fey'</pre><div class="note" title="Note"><h3 class="title"><a id="ch07note03"/>Note</h3><p><span class="emphasis"><em>You can find</em></span> all <span class="emphasis"><em>matching occurrences with the <code class="literal">findall()</code> method that’s discussed in <a class="xref" href="ch07.html#findallleft_parenthesisright_parenthesis" title="The findall() Method">The findall() Method</a>.</em></span></p></div><p><a id="iddle1054" class="indexterm"/><a id="iddle1621" class="indexterm"/><a id="iddle2270" class="indexterm"/><a id="iddle2313" class="indexterm"/>You can also use the pipe to match one of several patterns as part of your regex. For example, say you wanted to match any of the strings <code class="literal">'Batman'</code>, <code class="literal">'Batmobile'</code>, <code class="literal">'Batcopter'</code>, and <code class="literal">'Batbat'</code>. Since all these strings start with <code class="literal">Bat</code>, it would be nice if you could specify that prefix only once. This can be done with parentheses. Enter the following into the interactive shell:</p><a id="pro_id00283"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>batRegex = re.compile(r'Bat(man|mobile|copter|bat)')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo = batRegex.search('Batmobile lost a wheel')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo.group()</strong></span>
'Batmobile'
&gt;&gt;&gt; <span class="strong"><strong>mo.group(1)</strong></span>
'mobile'</pre><p>The method call <code class="literal">mo.group()</code> returns the full matched text <code class="literal">'Batmobile'</code>, while <code class="literal">mo.group(1)</code> returns just the part of the matched text inside the first parentheses group, <code class="literal">'mobile'</code>. By using the pipe character and grouping parentheses, you can specify several alternative patterns you would like your regex to match.</p><p>If you need to match an actual pipe character, escape it with a backslash, like <code class="literal">\|</code>.</p></div><div class="sect2" title="Optional Matching with the Question Mark"><div class="titlepage"><div><div><h2 class="title"><a id="optional_matching_with_the_question_mark"/>Optional Matching with the Question Mark</h2></div></div></div><p>Sometimes there is a pattern that you want to match only optionally. That is, the regex should find a match whether or not that bit of text is there. The <code class="literal">?</code> character flags the group that precedes it as an optional part of the pattern. For example, enter the following into the interactive shell:</p><a id="pro_id00284"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>batRegex = re.compile(r'Bat(wo)?man')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1 = batRegex.search('The Adventures of Batman')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1.group()</strong></span>
'Batman'

&gt;&gt;&gt; <span class="strong"><strong>mo2 = batRegex.search('The Adventures of Batwoman')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo2.group()</strong></span>
'Batwoman'</pre><p>The <code class="literal">(wo)?</code> part of the regular expression means that the pattern <code class="literal">wo</code> is an optional group. The regex will match text that has zero instances or one instance of <span class="emphasis"><em>wo</em></span> in it. This is why the regex matches both <code class="literal">'Batwoman'</code> and <code class="literal">'Batman'</code>.</p><p>Using the earlier phone number example, you can make the regex look for phone numbers that do or do not have an area code. Enter the following into the interactive shell:</p><a id="pro_id00285"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>phoneRegex = re.compile(r'(\d\d\d-)?\d\d\d-\d\d\d\d')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1 = phoneRegex.search('My number is 415-555-4242')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1.group()</strong></span>
'415-555-4242'

&gt;&gt;&gt; <span class="strong"><strong>mo2 = phoneRegex.search('My number is 555-4242')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo2.group()</strong></span>
'555-4242'</pre><p><a id="iddle1048" class="indexterm"/><a id="iddle1061" class="indexterm"/><a id="iddle1620" class="indexterm"/><a id="iddle1623" class="indexterm"/><a id="iddle2133" class="indexterm"/><a id="iddle2312" class="indexterm"/><a id="iddle2316" class="indexterm"/><a id="iddle2466" class="indexterm"/>You can think of the <code class="literal">?</code> as saying, “Match zero or one of the group preceding this question mark.”</p><p>If you need to match an actual question mark character, escape it with <code class="literal">\?</code>.</p></div><div class="sect2" title="Matching Zero or More with the Star"><div class="titlepage"><div><div><h2 class="title"><a id="matching_zero_or_more_with_the_star"/>Matching Zero or More with the Star</h2></div></div></div><p>The <code class="literal">*</code> (called the <span class="emphasis"><em>star</em></span> or <span class="emphasis"><em>asterisk</em></span>) means “match zero or more”—the group that precedes the star can occur any number of times in the text. It can be completely absent or repeated over and over again. Let’s look at the Batman example again.</p><a id="pro_id00286"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>batRegex = re.compile(r'Bat(wo)*man')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1 = batRegex.search('The Adventures of Batman')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1.group()</strong></span>
'Batman'

&gt;&gt;&gt; <span class="strong"><strong>mo2 = batRegex.search('The Adventures of Batwoman')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo2.group()</strong></span>
'Batwoman'

&gt;&gt;&gt; <span class="strong"><strong>mo3 = batRegex.search('The Adventures of Batwowowowoman')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo3.group()</strong></span>
'Batwowowowoman'</pre><p>For <code class="literal">'Batman'</code>, the <code class="literal">(wo)*</code> part of the regex matches zero instances of <code class="literal">wo</code> in the string; for <code class="literal">'Batwoman'</code>, the <code class="literal">(wo)*</code> matches one instance of <code class="literal">wo</code>; and for <code class="literal">'Batwowowowoman'</code>, <code class="literal">(wo)*</code> matches four instances of <code class="literal">wo</code>.</p><p>If you need to match an actual star character, prefix the star in the regular expression with a backslash, <code class="literal">\*</code>.</p></div><div class="sect2" title="Matching One or More with the Plus"><div class="titlepage"><div><div><h2 class="title"><a id="matching_one_or_more_with_the_plus"/>Matching One or More with the Plus</h2></div></div></div><p>While <code class="literal">*</code> means “match zero or more,” the <code class="literal">+</code> (or <span class="emphasis"><em>plus</em></span>) means “match one or more.” Unlike the star, which does not require its group to appear in the matched string, the group preceding a plus must appear <span class="emphasis"><em>at least once</em></span>. It is not optional. Enter the following into the interactive shell, and compare it with the star regexes in the previous section:</p><a id="pro_id00287"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>batRegex = re.compile(r'Bat(wo)+man')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1 = batRegex.search('The Adventures of Batwoman')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1.group()</strong></span>
'Batwoman'

&gt;&gt;&gt; <span class="strong"><strong>mo2 = batRegex.search('The Adventures of Batwowowowoman')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo2.group()</strong></span>
'Batwowowowoman'

&gt;&gt;&gt; <span class="strong"><strong>mo3 = batRegex.search('The Adventures of Batman')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo3 == None</strong></span>
True</pre><p><a id="iddle1018" class="indexterm"/><a id="iddle1019" class="indexterm"/><a id="iddle1250" class="indexterm"/><a id="iddle1251" class="indexterm"/><a id="iddle1615" class="indexterm"/><a id="iddle1618" class="indexterm"/><a id="iddle1622" class="indexterm"/><a id="iddle2310" class="indexterm"/><a id="iddle2311" class="indexterm"/>The regex <code class="literal">Bat(wo)+man</code> will not match the string <code class="literal">'The Adventures of Batman'</code> because at least one <code class="literal">wo</code> is required by the plus sign.</p><p>If you need to match an actual plus sign character, prefix the plus sign with a backslash to escape it: <code class="literal">\+</code>.</p></div><div class="sect2" title="Matching Specific Repetitions with Curly Brackets"><div class="titlepage"><div><div><h2 class="title"><a id="matching_specific_repetitions_with_curly"/>Matching Specific Repetitions with Curly Brackets</h2></div></div></div><p>If you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in curly brackets. For example, the regex <code class="literal">(Ha){3}</code> will match the string <code class="literal">'HaHaHa'</code>, but it will not match <code class="literal">'HaHa'</code>, since the latter has only two repeats of the <code class="literal">(Ha)</code> group.</p><p>Instead of one number, you can specify a range by writing a minimum, a comma, and a maximum in between the curly brackets. For example, the regex <code class="literal">(Ha){3,5}</code> will match <code class="literal">'HaHaHa'</code>, <code class="literal">'HaHaHaHa'</code>, and <code class="literal">'HaHaHaHaHa'</code>.</p><p>You can also leave out the first or second number in the curly brackets to leave the minimum or maximum unbounded. For example, <code class="literal">(Ha){3,}</code> will match three or more instances of the <code class="literal">(Ha)</code> group, while <code class="literal">(Ha){,5}</code> will match zero to five instances. Curly brackets can help make your regular expressions shorter. These two regular expressions match identical patterns:</p><a id="pro_id00288"/><pre class="programlisting">(Ha){3}
(Ha)(Ha)(Ha)</pre><p>And these two regular expressions also match identical patterns:</p><a id="pro_id00289"/><pre class="programlisting">(Ha){3,5}
((Ha)(Ha)(Ha))|((Ha)(Ha)(Ha)(Ha))|((Ha)(Ha)(Ha)(Ha)(Ha))</pre><p>Enter the following into the interactive shell:</p><a id="pro_id00290"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>haRegex = re.compile(r'(Ha){3}')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1 = haRegex.search('HaHaHa')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1.group()</strong></span>
'HaHaHa'

&gt;&gt;&gt; <span class="strong"><strong>mo2 = haRegex.search('Ha')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo2 == None</strong></span>
True</pre><p>Here, <code class="literal">(Ha){3}</code> matches <code class="literal">'HaHaHa'</code> but not <code class="literal">'Ha'</code>. Since it doesn’t match <code class="literal">'Ha'</code>, <code class="literal">search()</code> returns <code class="literal">None</code>.</p></div></div><div class="sect1" title="Greedy and Nongreedy Matching"><div class="titlepage"><div><div><h1 class="title"><a id="greedy_and_nongreedy_matching"/>Greedy and Nongreedy Matching</h1></div></div></div><p>Since <code class="literal">(Ha){3,5}</code> can match three, four, or five instances of <code class="literal">Ha</code> in the string <code class="literal">'HaHaHaHaHa'</code>, you may wonder why the <code class="literal">Match</code> object’s call to <code class="literal">group()</code> in the <a id="iddle1505" class="indexterm"/><a id="iddle1619" class="indexterm"/><a id="iddle2008" class="indexterm"/><a id="iddle2308" class="indexterm"/><a id="iddle2320" class="indexterm"/>previous curly bracket example returns <code class="literal">'HaHaHaHaHa'</code> instead of the shorter possibilities. After all, <code class="literal">'HaHaHa'</code> and <code class="literal">'HaHaHaHa'</code> are also valid matches of the regular expression <code class="literal">(Ha){3,5}</code>.</p><p>Python’s regular expressions are <span class="emphasis"><em>greedy</em></span> by default, which means that in ambiguous situations they will match the longest string possible. The <span class="emphasis"><em>non-greedy</em></span> version of the curly brackets, which matches the shortest string possible, has the closing curly bracket followed by a question mark.</p><p>Enter the following into the interactive shell, and notice the difference between the greedy and nongreedy forms of the curly brackets searching the same string:</p><a id="pro_id00291"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>greedyHaRegex = re.compile(r'(Ha){3,5}')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1 = greedyHaRegex.search('HaHaHaHaHa')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo1.group()</strong></span>
'HaHaHaHaHa'

&gt;&gt;&gt; <span class="strong"><strong>nongreedyHaRegex = re.compile(r'(Ha){3,5}?')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo2 = nongreedyHaRegex.search('HaHaHaHaHa')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo2.group()</strong></span>
'HaHaHa'</pre><p>Note that the question mark can have two meanings in regular expressions: declaring a nongreedy match or flagging an optional group. These meanings are entirely unrelated.</p></div><div class="sect1" title="The findall() Method"><div class="titlepage"><div><div><h1 class="title"><a id="findallleft_parenthesisright_parenthesis"/>The findall() Method</h1></div></div></div><p>In addition to the <code class="literal">search()</code> method, <code class="literal">Regex</code> objects also have a <code class="literal">findall()</code> method. While <code class="literal">search()</code> will return a <code class="literal">Match</code> object of the <span class="emphasis"><em>first</em></span> matched text in the searched string, the <code class="literal">findall()</code> method will return the strings of <span class="emphasis"><em>every</em></span> match in the searched string. To see how <code class="literal">search()</code> returns a <code class="literal">Match</code> object only on the first instance of matching text, enter the following into the interactive shell:</p><a id="pro_id00292"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo = phoneNumRegex.search('Cell: 415-555-9999 Work: 212-555-0000')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo.group()</strong></span>
'415-555-9999'</pre><p>On the other hand, <code class="literal">findall()</code> will not return a <code class="literal">Match</code> object but a list of strings—<span class="emphasis"><em>as long as there are no groups in the regular expression</em></span>. Each string in the list is a piece of the searched text that matched the regular expression. Enter the following into the interactive shell:</p><a id="pro_id00293"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groups</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')</strong></span>
['415-555-9999', '212-555-0000']</pre><p>If there <span class="emphasis"><em>are</em></span> groups in the regular expression, then <code class="literal">findall()</code> will return a list of tuples. Each tuple represents a found match, and its items are the <a id="iddle1167" class="indexterm"/><a id="iddle1253" class="indexterm"/><a id="iddle1254" class="indexterm"/><a id="iddle2303" class="indexterm"/><a id="iddle2370" class="indexterm"/><a id="iddle2371" class="indexterm"/><a id="iddle2647" class="indexterm"/><a id="iddle2648" class="indexterm"/>matched strings for each group in the regex. To see <code class="literal">findall()</code> in action, enter the following into the interactive shell (notice that the regular expression being compiled now has groups in parentheses):</p><a id="pro_id00294"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d)-(\d\d\d\d)') # has groups</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')</strong></span>
[('415', '555', '1122'), ('212', '555', '0000')]</pre><p>To summarize what the <code class="literal">findall()</code> method returns, remember the following:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>When called on a regex with no groups, such as <code class="literal">\d\d\d-\d\d\d-\d\d\d\d</code>, the method <code class="literal">findall()</code> returns a list of string matches, such as <code class="literal">['415-555-9999', '212-555-0000']</code>.</p></li><li class="listitem"><p>When called on a regex that has groups, such as <code class="literal">(\d\d\d)-(\d\d\d)-(\d\ d\d\d)</code>, the method <code class="literal">findall()</code> returns a list of tuples of strings (one string for each group), such as <code class="literal">[('415', '555', '1122'), ('212', '555', '0000')]</code>.</p></li></ol></div></div><div class="sect1" title="Character Classes"><div class="titlepage"><div><div><h1 class="title"><a id="character_classes"/>Character Classes</h1></div></div></div><p>In the earlier phone number regex example, you learned that <code class="literal">\d</code> could stand for any numeric digit. That is, <code class="literal">\d</code> is shorthand for the regular expression <code class="literal">(0|1|2|3|4|5|6|7|8|9)</code>. There are many such <span class="emphasis"><em>shorthand character classes</em></span>, as shown in <a class="xref" href="ch07.html#shorthand_codes_for_common_character_cla" title="Table 7-1. Shorthand Codes for Common Character Classes">Table 7-1</a>.</p><div class="table"><a id="shorthand_codes_for_common_character_cla"/><p class="title">Table 7-1. Shorthand Codes for Common Character Classes</p><div class="table-contents"><table summary="Shorthand Codes for Common Character Classes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Shorthand character class</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Represents</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">\d</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Any numeric digit from 0 to 9.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">\D</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Any character that is <span class="emphasis"><em>not</em></span> a numeric digit from 0 to 9.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">\w</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Any letter, numeric digit, or the underscore character. (Think of this as matching “word” characters.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">\W</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Any character that is <span class="emphasis"><em>not</em></span> a letter, numeric digit, or the underscore character.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">\s</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Any space, tab, or newline character. (Think of this as matching “space” characters.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">\S</code></p></td><td style="" valign="top"><p>Any character that is <span class="emphasis"><em>not</em></span> a space, tab, or newline.</p></td></tr></tbody></table></div></div><p>Character classes are nice for shortening regular expressions. The character class <code class="literal">[0-5]</code> will match only the numbers <code class="literal">0</code> to <code class="literal">5</code>; this is much shorter than typing <code class="literal">(0|1|2|3|4|5)</code>.</p><p>For example, enter the following into the interactive shell:</p><a id="pro_id00295"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>xmasRegex = re.compile(r'\d+\s\w+')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>xmasRegex.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7</strong></span>
<span class="strong"><strong>swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge')</strong></span>
['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', '6
geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge']</pre><p><a id="iddle1009" class="indexterm"/><a id="iddle1010" class="indexterm"/><a id="iddle1020" class="indexterm"/><a id="iddle1152" class="indexterm"/><a id="iddle1153" class="indexterm"/><a id="iddle1343" class="indexterm"/><a id="iddle2002" class="indexterm"/><a id="iddle2301" class="indexterm"/><a id="iddle2306" class="indexterm"/>The regular expression <code class="literal">\d+\s\w+</code> will match text that has one or more numeric digits (<code class="literal">\d+</code>), followed by a whitespace character (<code class="literal">\s</code>), followed by one or more letter/digit/underscore characters (<code class="literal">\w+</code>). The <code class="literal">findall()</code> method returns all matching strings of the regex pattern in a list.</p></div><div class="sect1" title="Making Your Own Character Classes"><div class="titlepage"><div><div><h1 class="title"><a id="making_your_own_character_classes"/>Making Your Own Character Classes</h1></div></div></div><p>There are times when you want to match a set of characters but the shorthand character classes (<code class="literal">\d</code>, <code class="literal">\w</code>, <code class="literal">\s</code>, and so on) are too broad. You can define your own character class using square brackets. For example, the character class <code class="literal">[aeiouAEIOU]</code> will match any vowel, both lowercase and uppercase. Enter the following into the interactive shell:</p><a id="pro_id00296"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>vowelRegex = re.compile(r'[aeiouAEIOU]')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>vowelRegex.findall('RoboCop eats baby food. BABY FOOD.')</strong></span>
['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O']</pre><p>You can also include ranges of letters or numbers by using a hyphen. For example, the character class <code class="literal">[a-zA-Z0-9]</code> will match all lowercase letters, uppercase letters, and numbers.</p><p>Note that inside the square brackets, the normal regular expression symbols are not interpreted as such. This means you do not need to escape the <code class="literal">.</code>, <code class="literal">*</code>, <code class="literal">?</code>, or <code class="literal">()</code> characters with a preceding backslash. For example, the character class <code class="literal">[0-5.]</code> will match digits <code class="literal">0</code> to <code class="literal">5</code> and a period. You do not need to write it as <code class="literal">[0-5\.]</code>.</p><p>By placing a caret character (<code class="literal">^</code>) just after the character class’s opening bracket, you can make a <span class="emphasis"><em>negative character class</em></span>. A negative character class will match all the characters that are <span class="emphasis"><em>not</em></span> in the character class. For example, enter the following into the interactive shell:</p><a id="pro_id00297"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>consonantRegex = re.compile(r'[^aeiouAEIOU]')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>consonantRegex.findall('RoboCop eats baby food. BABY FOOD.')</strong></span>
['R', 'b', 'c', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f', 'd', '.', '
', 'B', 'B', 'Y', ' ', 'F', 'D', '.']</pre><p>Now, instead of matching every vowel, we’re matching every character that isn’t a vowel.</p></div><div class="sect1" title="The Caret and Dollar Sign Characters"><div class="titlepage"><div><div><h1 class="title"><a id="caret_and_dollar_sign_characters"/>The Caret and Dollar Sign Characters</h1></div></div></div><p>You can also use the caret symbol (<code class="literal">^</code>) at the start of a regex to indicate that a match must occur at the <span class="emphasis"><em>beginning</em></span> of the searched text. Likewise, you can put a dollar sign (<code class="literal">$</code>) at the end of the regex to indicate the string must <span class="emphasis"><em>end</em></span> with this regex pattern. And you can use the <code class="literal">^</code> and <code class="literal">$</code> together to indicate that the entire string must match the regex—that is, it’s not enough for a match to be made on some subset of the string.</p><p><a id="iddle1022" class="indexterm"/><a id="iddle1024" class="indexterm"/><a id="iddle1345" class="indexterm"/><a id="iddle1347" class="indexterm"/><a id="iddle2325" class="indexterm"/><a id="iddle2690" class="indexterm"/>For example, the <code class="literal">r'^Hello'</code> regular expression string matches strings that begin with <code class="literal">'Hello'</code>. Enter the following into the interactive shell:</p><a id="pro_id00298"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>beginsWithHello = re.compile(r'^Hello')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>beginsWithHello.search('Hello world!')</strong></span>
&lt;_sre.SRE_Match object; span=(0, 5), match='Hello'&gt;
&gt;&gt;&gt; <span class="strong"><strong>beginsWithHello.search('He said hello.') == None</strong></span>
True</pre><p>The <code class="literal">r'\d$'</code> regular expression string matches strings that end with a numeric character from 0 to 9. Enter the following into the interactive shell:</p><a id="pro_id00299"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>endsWithNumber = re.compile(r'\d$')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>endsWithNumber.search('Your number is 42')</strong></span>
&lt;_sre.SRE_Match object; span=(16, 17), match='2'&gt;
&gt;&gt;&gt; <span class="strong"><strong>endsWithNumber.search('Your number is forty two.') == None</strong></span>
True</pre><p>The <code class="literal">r'^\d+$'</code> regular expression string matches strings that both begin and end with one or more numeric characters. Enter the following into the interactive shell:</p><a id="pro_id00300"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>wholeStringIsNum = re.compile(r'^\d+$')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>wholeStringIsNum.search('1234567890')</strong></span>
&lt;_sre.SRE_Match object; span=(0, 10), match='1234567890'&gt;
&gt;&gt;&gt; <span class="strong"><strong>wholeStringIsNum.search('12345xyz67890') == None</strong></span>
True
&gt;&gt;&gt; <span class="strong"><strong>wholeStringIsNum.search('12 34567890') == None</strong></span>
True</pre><p>The last two <code class="literal">search()</code> calls in the previous interactive shell example demonstrate how the entire string must match the regex if <code class="literal">^</code> and <code class="literal">$</code> are used.</p><p>I always confuse the meanings of these two symbols, so I use the mnemonic “Carrots cost dollars” to remind myself that the caret comes first and the dollar sign comes last.</p></div><div class="sect1" title="The Wildcard Character"><div class="titlepage"><div><div><h1 class="title"><a id="wildcard_character"/>The Wildcard Character</h1></div></div></div><p>The <code class="literal">.</code> (or <span class="emphasis"><em>dot</em></span>) character in a regular expression is called a <span class="emphasis"><em>wildcard</em></span> and will match any character except for a newline. For example, enter the following into the interactive shell:</p><a id="pro_id00301"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>atRegex = re.compile(r'.at')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>atRegex.findall('The cat in the hat sat on the flat mat.')</strong></span>
['cat', 'hat', 'sat', 'lat', 'mat']</pre><p><a id="iddle1060" class="indexterm"/><a id="iddle1348" class="indexterm"/><a id="iddle1614" class="indexterm"/><a id="iddle2007" class="indexterm"/><a id="iddle2463" class="indexterm"/><a id="iddle2465" class="indexterm"/>Remember that the dot character will match just one character, which is why the match for the text <code class="literal">flat</code> in the previous example matched only <code class="literal">lat</code>. To match an actual dot, escape the dot with a backslash: <code class="literal">\.</code>.</p><div class="sect2" title="Matching Everything with Dot-Star"><div class="titlepage"><div><div><h2 class="title"><a id="matching_everything_with_dot-star"/>Matching Everything with Dot-Star</h2></div></div></div><p>Sometimes you will want to match everything and anything. For example, say you want to match the string <code class="literal">'First Name:'</code>, followed by any and all text, followed by <code class="literal">'Last Name:'</code>, and then followed by anything again. You can use the dot-star (<code class="literal">.*</code>) to stand in for that “anything.” Remember that the dot character means “any single character except the newline,” and the star character means “zero or more of the preceding character.”</p><p>Enter the following into the interactive shell:</p><a id="pro_id00302"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>nameRegex = re.compile(r'First Name: (.*) Last Name: (.*)')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo = nameRegex.search('First Name: Al Last Name: Sweigart')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo.group(1)</strong></span>
'Al'
&gt;&gt;&gt; <span class="strong"><strong>mo.group(2)</strong></span>
'Sweigart'</pre><p>The dot-star uses <span class="emphasis"><em>greedy</em></span> mode: It will always try to match as much text as possible. To match any and all text in a <span class="emphasis"><em>nongreedy</em></span> fashion, use the dot, star, and question mark (<code class="literal">.*?</code>). Like with curly brackets, the question mark tells Python to match in a nongreedy way.</p><p>Enter the following into the interactive shell to see the difference between the greedy and nongreedy versions:</p><a id="pro_id00303"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>nongreedyRegex = re.compile(r'&lt;.*?&gt;')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo = nongreedyRegex.search('&lt;To serve man&gt; for dinner.&gt;')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo.group()</strong></span>
'&lt;To serve man&gt;'

&gt;&gt;&gt; <span class="strong"><strong>greedyRegex = re.compile(r'&lt;.*&gt;')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo = greedyRegex.search('&lt;To serve man&gt; for dinner.&gt;')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>mo.group()</strong></span>
'&lt;To serve man&gt; for dinner.&gt;'</pre><p>Both regexes roughly translate to “Match an opening angle bracket, followed by anything, followed by a closing angle bracket.” But the string <code class="literal">'&lt;To serve man&gt; for dinner.&gt;'</code> has two possible matches for the closing angle bracket. In the nongreedy version of the regex, Python matches the shortest possible string: <code class="literal">'&lt;To serve man&gt;'</code>. In the greedy version, Python matches the longest possible string: <code class="literal">'&lt;To serve man&gt; for dinner.&gt;'</code>.</p></div><div class="sect2" title="Matching Newlines with the Dot Character"><div class="titlepage"><div><div><h2 class="title"><a id="matching_newlines_with_the_dot_character"/>Matching Newlines with the Dot Character</h2></div></div></div><p><a id="iddle1005" class="indexterm"/><a id="iddle1008" class="indexterm"/><a id="iddle1017" class="indexterm"/><a id="iddle1021" class="indexterm"/><a id="iddle1049" class="indexterm"/><a id="iddle1055" class="indexterm"/><a id="iddle1058" class="indexterm"/><a id="iddle1059" class="indexterm"/><a id="iddle1110" class="indexterm"/><a id="iddle1151" class="indexterm"/><a id="iddle1168" class="indexterm"/><a id="iddle1249" class="indexterm"/><a id="iddle1344" class="indexterm"/><a id="iddle2134" class="indexterm"/><a id="iddle2271" class="indexterm"/><a id="iddle2324" class="indexterm"/><a id="iddle2464" class="indexterm"/>The dot-star will match everything except a newline. By passing <code class="literal">re.DOTALL</code> as the second argument to <code class="literal">re.compile()</code>, you can make the dot character match <span class="emphasis"><em>all</em></span> characters, including the newline character.</p><p>Enter the following into the interactive shell:</p><a id="pro_id00304"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>noNewlineRegex = re.compile('.*')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>noNewlineRegex.search('Serve the public trust.\nProtect the innocent.</strong></span>
<span class="strong"><strong>\nUphold the law.').group()</strong></span>
'Serve the public trust.'

&gt;&gt;&gt; <span class="strong"><strong>newlineRegex = re.compile('.*', re.DOTALL)</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>newlineRegex.search('Serve the public trust.\nProtect the innocent.</strong></span>
<span class="strong"><strong>\nUphold the law.').group()</strong></span>
'Serve the public trust.\nProtect the innocent.\nUphold the law.'</pre><p>The regex <code class="literal">noNewlineRegex</code>, which did not have <code class="literal">re.DOTALL</code> passed to the <code class="literal">re.compile()</code> call that created it, will match everything only up to the first newline character, whereas <code class="literal">newlineRegex</code>, which <span class="emphasis"><em>did</em></span> have <code class="literal">re.DOTALL</code> passed to <code class="literal">re.compile()</code>, matches everything. This is why the <code class="literal">newlineRegex.search()</code> call matches the full string, including its newline characters.</p></div></div><div class="sect1" title="Review of Regex Symbols"><div class="titlepage"><div><div><h1 class="title"><a id="review_of_regex_symbols"/>Review of Regex Symbols</h1></div></div></div><p>This chapter covered a lot of notation, so here’s a quick review of what you learned:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">?</code> matches zero or one of the preceding group.</p></li><li class="listitem"><p>The <code class="literal">*</code> matches zero or more of the preceding group.</p></li><li class="listitem"><p>The <code class="literal">+</code> matches one or more of the preceding group.</p></li><li class="listitem"><p>The <code class="literal">{n}</code> matches exactly <span class="emphasis"><em>n</em></span> of the preceding group.</p></li><li class="listitem"><p>The <code class="literal">{n,}</code> matches <span class="emphasis"><em>n</em></span> or more of the preceding group.</p></li><li class="listitem"><p>The <code class="literal">{,m}</code> matches 0 to <span class="emphasis"><em>m</em></span> of the preceding group.</p></li><li class="listitem"><p>The <code class="literal">{n,m}</code> matches at least <span class="emphasis"><em>n</em></span> and at most <span class="emphasis"><em>m</em></span> of the preceding group.</p></li><li class="listitem"><p><code class="literal">{n,m}?</code> or <code class="literal">*?</code> or <code class="literal">+?</code> performs a nongreedy match of the preceding group.</p></li><li class="listitem"><p><code class="literal">^spam</code> means the string must begin with <span class="emphasis"><em>spam</em></span>.</p></li><li class="listitem"><p><code class="literal">spam$</code> means the string must end with <span class="emphasis"><em>spam</em></span>.</p></li><li class="listitem"><p>The <code class="literal">.</code> matches any character, except newline characters.</p></li><li class="listitem"><p><code class="literal">\d</code>, <code class="literal">\w</code>, and <code class="literal">\s</code> match a digit, word, or space character, respectively.</p></li><li class="listitem"><p><code class="literal">\D</code>, <code class="literal">\W</code>, and <code class="literal">\S</code> match anything except a digit, word, or space character, respectively.</p></li><li class="listitem"><p><code class="literal">[abc]</code> matches any character between the brackets (such as <span class="emphasis"><em>a</em></span>, <span class="emphasis"><em>b</em></span>, or <span class="emphasis"><em>c</em></span>).</p></li><li class="listitem"><p><code class="literal">[^abc]</code> matches any character that isn’t between the brackets.</p></li></ul></div></div><div class="sect1" title="Case-Insensitive Matching"><div class="titlepage"><div><div><h1 class="title"><a id="case-insensitive_matching"/>Case-Insensitive Matching</h1></div></div></div><p><a id="iddle1157" class="indexterm"/><a id="iddle2302" class="indexterm"/><a id="iddle2323" class="indexterm"/><a id="iddle2522" class="indexterm"/><a id="iddle2531" class="indexterm"/>Normally, regular expressions match text with the exact casing you specify. For example, the following regexes match completely different strings:</p><a id="pro_id00305"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>regex1 = re.compile('RoboCop')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>regex2 = re.compile('ROBOCOP')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>regex3 = re.compile('robOcop')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>regex4 = re.compile('RobocOp')</strong></span></pre><p>But sometimes you care only about matching the letters without worrying whether they’re uppercase or lowercase. To make your regex case-insensitive, you can pass <code class="literal">re.IGNORECASE</code> or <code class="literal">re.I</code> as a second argument to <code class="literal">re.compile()</code>. Enter the following into the interactive shell:</p><a id="pro_id00306"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>robocop = re.compile(r'robocop', re.I)</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>robocop.search('RoboCop is part man, part machine, all cop.').group()</strong></span>
'RoboCop'

&gt;&gt;&gt; <span class="strong"><strong>robocop.search('ROBOCOP protects the innocent.').group()</strong></span>
'ROBOCOP'

&gt;&gt;&gt; <span class="strong"><strong>robocop.search('Al, why does your programming book talk about robocop so much?').group()</strong></span>
'robocop'</pre></div><div class="sect1" title="Substituting Strings with the sub() Method"><div class="titlepage"><div><div><h1 class="title"><a id="substituting_strings_with_the_subleft_pa"/>Substituting Strings with the sub() Method</h1></div></div></div><p>Regular expressions can not only find text patterns but can also substitute new text in place of those patterns. The <code class="literal">sub()</code> method for <code class="literal">Regex</code> objects is passed two arguments. The first argument is a string to replace any matches. The second is the string for the regular expression. The <code class="literal">sub()</code> method returns a string with the substitutions applied.</p><p>For example, enter the following into the interactive shell:</p><a id="pro_id00307"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>namesRegex = re.compile(r'Agent \w+')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')</strong></span>
'CENSORED gave the secret documents to CENSORED.'</pre><p>Sometimes you may need to use the matched text itself as part of the substitution. In the first argument to <code class="literal">sub()</code>, you can type <code class="literal">\1</code>, <code class="literal">\2</code>, <code class="literal">\3</code>, and so on, to mean “Enter the text of group <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code>, and so on, in the substitution.”</p><p>For example, say you want to censor the names of the secret agents by showing just the first letters of their names. To do this, you could use the regex <code class="literal">Agent (\w)\w*</code> and pass <code class="literal">r'\1****'</code> as the first argument to <code class="literal">sub()</code>. The <code class="literal">\1</code> in that string will be replaced by whatever text was matched by group <code class="literal">1</code>—that is, the <code class="literal">(\w)</code> group of the regular expression.</p><a id="pro_id00308"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>agentNamesRegex = re.compile(r'Agent (\w)\w*')</strong></span>
&gt;&gt;&gt; <span class="strong"><strong>agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent</strong></span>
<span class="strong"><strong>Eve knew Agent Bob was a double agent.')</strong></span>
A**** told C**** that E**** knew B**** was a double agent.'</pre></div><div class="sect1" title="Managing Complex Regexes"><div class="titlepage"><div><div><h1 class="title"><a id="managing_complex_regexes"/>Managing Complex Regexes</h1></div></div></div><p><a id="iddle1047" class="indexterm"/><a id="iddle1065" class="indexterm"/><a id="iddle1121" class="indexterm"/><a id="iddle1202" class="indexterm"/><a id="iddle2126" class="indexterm"/><a id="iddle2319" class="indexterm"/><a id="iddle2322" class="indexterm"/><a id="iddle2588" class="indexterm"/>Regular expressions are fine if the text pattern you need to match is simple. But matching complicated text patterns might require long, convoluted regular expressions. You can mitigate this by telling the <code class="literal">re.compile()</code> function to ignore whitespace and comments inside the regular expression string. This “verbose mode” can be enabled by passing the variable <code class="literal">re.VERBOSE</code> as the second argument to <code class="literal">re.compile()</code>.</p><p>Now instead of a hard-to-read regular expression like this:</p><a id="pro_id00309"/><pre class="programlisting">phoneRegex = re.compile(r'((\d{3}|\(\d{3}\))?(\s|-|\.)?\d{3}(\s|-|\.)\d{4}
(\s*(ext|x|ext.)\s*\d{2,5})?)')</pre><p>you can spread the regular expression over multiple lines with comments like this:</p><a id="pro_id00310"/><pre class="programlisting">phoneRegex = re.compile(r'''(
    (\d{3}|\(\d{3}\))?            # area code
    (\s|-|\.)?                    # separator
    \d{3}                         # first 3 digits
    (\s|-|\.)                     # separator
    \d{4}                         # last 4 digits
    (\s*(ext|x|ext.)\s*\d{2,5})?  # extension
    )''', re.VERBOSE)</pre><p>Note how the previous example uses the triple-quote syntax (<code class="literal">'''</code>) to create a multiline string so that you can spread the regular expression definition over many lines, making it much more legible.</p><p>The comment rules inside the regular expression string are the same as regular Python code: The <code class="literal">#</code> symbol and everything after it to the end of the line are ignored. Also, the extra spaces inside the multiline string for the regular expression are not considered part of the text pattern to be matched. This lets you organize the regular expression so it’s easier to read.</p></div><div class="sect1" title="Combining re.IGNORECASE, re.DOTALL, and re.VERBOSE"><div class="titlepage"><div><div><h1 class="title"><a id="combining_redotignorecasecomma_redotdota"/>Combining re.IGNORECASE, re.DOTALL, and re.VERBOSE</h1></div></div></div><p>What if you want to use <code class="literal">re.VERBOSE</code> to write comments in your regular expression but also want to use <code class="literal">re.IGNORECASE</code> to ignore capitalization? Unfortunately, the <code class="literal">re.compile()</code> function takes only a single value as its second argument. You can get around this limitation by combining the <code class="literal">re.IGNORECASE</code>, <code class="literal">re.DOTALL</code>, and <code class="literal">re.VERBOSE</code> variables using the pipe character (<code class="literal">|</code>), which in this context is known as the <span class="emphasis"><em>bitwise or</em></span> operator.</p><p><a id="iddle1380" class="indexterm"/><a id="iddle1384" class="indexterm"/><a id="iddle2102" class="indexterm"/><a id="iddle2106" class="indexterm"/><a id="iddle2192" class="indexterm"/><a id="iddle2307" class="indexterm"/>So if you want a regular expression that’s case-insensitive <span class="emphasis"><em>and</em></span> includes newlines to match the dot character, you would form your <code class="literal">re.compile()</code> call like this:</p><a id="pro_id00311"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>someRegexValue = re.compile('foo', re.IGNORECASE | re.DOTALL)</strong></span></pre><p>All three options for the second argument will look like this:</p><a id="pro_id00312"/><pre class="programlisting">&gt;&gt;&gt; <span class="strong"><strong>someRegexValue = re.compile('foo', re.IGNORECASE | re.DOTALL | re.VERBOSE)</strong></span></pre><p>This syntax is a little old-fashioned and originates from early versions of Python. The details of the bitwise operators are beyond the scope of this book, but check out the resources at <span class="emphasis"><em><a class="ulink" href="http://nostarch.com/automatestuff/">http://nostarch.com/automatestuff/</a></em></span> for more information. You can also pass other options for the second argument; they’re uncommon, but you can read more about them in the resources, too.</p></div><div class="sect1" title="Project: Phone Number and Email Address Extractor"><div class="titlepage"><div><div><h1 class="title"><a id="project_phone_number_and_email_address_e"/>Project: Phone Number and Email Address Extractor</h1></div></div></div><p>Say you have the boring task of finding every phone number and email address in a long web page or document. If you manually scroll through the page, you might end up searching for a long time. But if you had a program that could search the text in your clipboard for phone numbers and email addresses, you could simply press <span class="smaller">CTRL</span>-A to select all the text, press <span class="smaller">CTRL</span>-C to copy it to the clipboard, and then run your program. It could replace the text on the clipboard with just the phone numbers and email addresses it finds.</p><p>Whenever you’re tackling a new project, it can be tempting to dive right into writing code. But more often than not, it’s best to take a step back and consider the bigger picture. I recommend first drawing up a high-level plan for what your program needs to do. Don’t think about the actual code yet—you can worry about that later. Right now, stick to broad strokes.</p><p>For example, your phone and email address extractor will need to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Get the text off the clipboard.</p></li><li class="listitem"><p>Find all phone numbers and email addresses in the text.</p></li><li class="listitem"><p>Paste them onto the clipboard.</p></li></ul></div><p>Now you can start thinking about how this might work in code. The code will need to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use the <code class="literal">pyperclip</code> module to copy and paste strings.</p></li><li class="listitem"><p>Create two regexes, one for matching phone numbers and the other for matching email addresses.</p></li><li class="listitem"><p>Find all matches, not just the first match, of both regexes.</p></li><li class="listitem"><p>Neatly format the matched strings into a single string to paste.</p></li><li class="listitem"><p>Display some kind of message if no matches were found in the text.</p></li></ul></div><p><a id="iddle1381" class="indexterm"/><a id="iddle2103" class="indexterm"/>This list is like a road map for the project. As you write the code, you can focus on each of these steps separately. Each step is fairly manageable and expressed in terms of things you already know how to do in Python.</p><div class="sect2" title="Step 1: Create a Regex for Phone Numbers"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_create_a_regex_for_phone_numbers"/>Step 1: Create a Regex for Phone Numbers</h2></div></div></div><p>First, you have to create a regular expression to search for phone numbers. Create a new file, enter the following, and save it as <span class="emphasis"><em>phoneAndEmail.py</em></span>:</p><a id="pro_id00313"/><pre class="programlisting">#! python3
# phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard.

import pyperclip, re

phoneRegex = re.compile(r'''(
    (\d{3}|\(\d{3}\))?                # area code
    (\s|-|\.)?                        # separator
    (\d{3})                           # first 3 digits
    (\s|-|\.)                         # separator
    (\d{4})                           # last 4 digits
    (\s*(ext|x|ext.)\s*(\d{2,5}))?    # extension
    )''', re.VERBOSE)

# TODO: Create email regex.

# TODO: Find matches in clipboard text.

# TODO: Copy results to the clipboard.</pre><p>The <code class="literal">TODO</code> comments are just a skeleton for the program. They’ll be replaced as you write the actual code.</p><p>The phone number begins with an <span class="emphasis"><em>optional</em></span> area code, so the area code group is followed with a question mark. Since the area code can be just three digits (that is, <code class="literal">\d{3}</code>) <span class="emphasis"><em>or</em></span> three digits within parentheses (that is, <code class="literal">\(\d{3}\)</code>), you should have a pipe joining those parts. You can add the regex comment <code class="literal"># Area code</code> to this part of the multiline string to help you remember what <code class="literal">(\d{3}|\(\d{3}\))?</code> is supposed to match.</p><p>The phone number separator character can be a space (<code class="literal">\s</code>), hyphen (<code class="literal">-</code>), or period (<code class="literal">.</code>), so these parts should also be joined by pipes. The next few parts of the regular expression are straightforward: three digits, followed by another separator, followed by four digits. The last part is an optional extension made up of any number of spaces followed by <code class="literal">ext</code>, <code class="literal">x</code>, or <code class="literal">ext.</code>, followed by two to five digits.</p></div><div class="sect2" title="Step 2: Create a Regex for Email Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_create_a_regex_for_email_addresse"/>Step 2: Create a Regex for Email Addresses</h2></div></div></div><p>You will also need a regular expression that can match email addresses. Make your program look like the following:</p><a id="pro_id00314"/><pre class="programlisting">   #! python3
   # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard.
   import pyperclip, re

   phoneRegex = re.compile(r'''(
   <span class="emphasis"><em>--snip--</em></span>

   <span class="strong"><strong># Create email regex.</strong></span>
   <span class="strong"><strong>emailRegex = re.compile(r'''(</strong></span>
➊     <span class="strong"><strong>[a-zA-Z0-9._%+-]+      # username</strong></span>
➋     <span class="strong"><strong>@                      # @ symbol</strong></span>
➌     <span class="strong"><strong>[a-zA-Z0-9.-]+         # domain name</strong></span>
       <span class="strong"><strong>(\.[a-zA-Z]{2,4})      # dot-something</strong></span>
       <span class="strong"><strong>)''', re.VERBOSE)</strong></span>

   # TODO: Find matches in clipboard text.

   # TODO: Copy results to the clipboard.</pre><p><a id="iddle1382" class="indexterm"/><a id="iddle2104" class="indexterm"/><a id="iddle2579" class="indexterm"/>The username part of the email address ➊ is one or more characters that can be any of the following: lowercase and uppercase letters, numbers, a dot, an underscore, a percent sign, a plus sign, or a hyphen. You can put all of these into a character class: <code class="literal">[a-zA-Z0-9._%+-]</code>.</p><p>The domain and username are separated by an <span class="emphasis"><em>@</em></span> symbol ➋. The domain name ➌ has a slightly less permissive character class with only letters, numbers, periods, and hyphens: <code class="literal">[a-zA-Z0-9.-]</code>. And last will be the “dot-com” part (technically known as the <span class="emphasis"><em>top-level domain</em></span>), which can really be dot-anything. This is between two and four characters.</p><p>The format for email addresses has a lot of weird rules. This regular expression won’t match every possible valid email address, but it’ll match almost any typical email address you’ll encounter.</p></div><div class="sect2" title="Step 3: Find All Matches in the Clipboard Text"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_find_all_matches_in_the_clipboard"/>Step 3: Find All Matches in the Clipboard Text</h2></div></div></div><p>Now that you have specified the regular expressions for phone numbers and email addresses, you can let Python’s <code class="literal">re</code> module do the hard work of finding all the matches on the clipboard. The <code class="literal">pyperclip.paste()</code> function will get a string value of the text on the clipboard, and the <code class="literal">findall()</code> regex method will return a list of tuples.</p><p>Make your program look like the following:</p><a id="pro_id00315"/><pre class="programlisting">   #! python3
   # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard.

   import pyperclip, re

   phoneRegex = re.compile(r'''(
   <span class="emphasis"><em>--snip--</em></span>

   <span class="strong"><strong># Find matches in clipboard text.</strong></span>
   <span class="strong"><strong>text = str(pyperclip.paste())</strong></span>
➊ <span class="strong"><strong>matches = []</strong></span>
➋ <span class="strong"><strong>for groups in phoneRegex.findall(text):</strong></span>
       <span class="strong"><strong>phoneNum = '-'.join([groups[1], groups[3], groups[5]])</strong></span>
       <span class="strong"><strong>if groups[8] != '':</strong></span>
           <span class="strong"><strong>phoneNum += ' x' + groups[8]</strong></span>
       <span class="strong"><strong>matches.append(phoneNum)</strong></span>
➌ <span class="strong"><strong>for groups in emailRegex.findall(text):</strong></span>
       <span class="strong"><strong>matches.append(groups[0])</strong></span>

   # TODO: Copy results to the clipboard.</pre><p><a id="iddle1383" class="indexterm"/><a id="iddle2105" class="indexterm"/>There is one tuple for each match, and each tuple contains strings for each group in the regular expression. Remember that group <code class="literal">0</code> matches the entire regular expression, so the group at index <code class="literal">0</code> of the tuple is the one you are interested in.</p><p>As you can see at ➊, you’ll store the matches in a list variable named <code class="literal">matches</code>. It starts off as an empty list, and a couple <code class="literal">for</code> loops. For the email addresses, you append group <code class="literal">0</code> of each match ➌. For the matched phone numbers, you don’t want to just append group <code class="literal">0</code>. While the program <span class="emphasis"><em>detects</em></span> phone numbers in several formats, you want the phone number appended to be in a single, standard format. The <code class="literal">phoneNum</code> variable contains a string built from groups <code class="literal">1</code>, <code class="literal">3</code>, <code class="literal">5</code>, and <code class="literal">8</code> of the matched text ➋. (These groups are the area code, first three digits, last four digits, and extension.)</p></div><div class="sect2" title="Step 4: Join the Matches into a String for the Clipboard"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_join_the_matches_into_a_string_fo"/>Step 4: Join the Matches into a String for the Clipboard</h2></div></div></div><p>Now that you have the email addresses and phone numbers as a list of strings in <code class="literal">matches</code>, you want to put them on the clipboard. The <code class="literal">pyperclip.copy()</code> function takes only a single string value, not a list of strings, so you call the <code class="literal">join()</code> method on <code class="literal">matches</code>.</p><p>To make it easier to see that the program is working, let’s print any matches you find to the terminal. And if no phone numbers or email addresses were found, the program should tell the user this.</p><p>Make your program look like the following:</p><a id="pro_id00316"/><pre class="programlisting">#! python3
# phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard.

<span class="emphasis"><em>--snip--</em></span>
for groups in emailRegex.findall(text):
    matches.append(groups[0])

<span class="strong"><strong># Copy results to the clipboard.</strong></span>
<span class="strong"><strong>if len(matches) &gt; 0:</strong></span>
    <span class="strong"><strong>pyperclip.copy('\n'.join(matches))</strong></span>
    <span class="strong"><strong>print('Copied to clipboard:')</strong></span>
    <span class="strong"><strong>print('\n'.join(matches))</strong></span>
<span class="strong"><strong>else:</strong></span>
    <span class="strong"><strong>print('No phone numbers or email addresses found.')</strong></span></pre></div><div class="sect2" title="Running the Program"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_program"/>Running the Program</h2></div></div></div><p>For an example, open your web browser to the No Starch Press contact page at <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/contactus.htm">http://www.nostarch.com/contactus.htm</a></em></span>, press <span class="smaller">CTRL</span>-A to select all the text on the page, and press <span class="smaller">CTRL</span>-C to copy it to the clipboard. When you run this program, the output will look something like this:</p><a id="pro_id00317"/><pre class="programlisting">Copied to clipboard:
800-420-7240
415-863-9900
415-863-9950
info@nostarch.com
media@nostarch.com
academic@nostarch.com
help@nostarch.com</pre></div><div class="sect2" title="Ideas for Similar Programs"><div class="titlepage"><div><div><h2 class="title"><a id="ideas_for_similar_programs"/>Ideas for Similar Programs</h2></div></div></div><p>Identifying patterns of text (and possibly substituting them with the <code class="literal">sub()</code> method) has many different potential applications.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Find website URLs that begin with <span class="emphasis"><em>http://</em></span> or <span class="emphasis"><em>https://</em></span>.</p></li><li class="listitem"><p>Clean up dates in different date formats (such as 3/14/2015, 03-14-2015, and 2015/3/14) by replacing them with dates in a single, standard format.</p></li><li class="listitem"><p>Remove sensitive information such as Social Security or credit card numbers.</p></li><li class="listitem"><p>Find common typos such as multiple spaces between words, accidentally accidentally repeated words, or multiple exclamation marks at the end of sentences. Those are annoying!!</p></li></ul></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00020"/>Summary</h1></div></div></div><p>While a computer can search for text quickly, it must be told precisely what to look for. Regular expressions allow you to specify the precise patterns of characters you are looking for. In fact, some word processing and spreadsheet applications provide find-and-replace features that allow you to search using regular expressions.</p><p>The <code class="literal">re</code> module that comes with Python lets you compile <code class="literal">Regex</code> objects. These values have several methods: <code class="literal">search()</code> to find a single match, <code class="literal">findall()</code> to find all matching instances, and <code class="literal">sub()</code> to do a find-and-replace substitution of text.</p><p>There’s a bit more to regular expression syntax than is described in this chapter. You can find out more in the official Python documentation at <span class="emphasis"><em><a class="ulink" href="http://docs.python.org/3/library/re.html">http://docs.python.org/3/library/re.html</a></em></span>. The tutorial website <span class="emphasis"><em><a class="ulink" href="http://www.regular-expressions.info/">http://www.regular-expressions.info/</a></em></span> is also a useful resource.</p><p>Now that you have expertise manipulating and matching strings, it’s time to dive into how to read from and write to files on your computer’s hard drive.</p></div><div class="sect1" title="Practice Questions"><div class="titlepage"><div><div><h1 class="title"><a id="practice_questions-id00021"/>Practice Questions</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch07qa1"/><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe1"/><a id="ch07qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. What is the function that creates <code class="literal">Regex</code> objects?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe2"/><a id="ch07qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. Why are raw strings often used when creating <code class="literal">Regex</code> objects?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe3"/><a id="ch07qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. What does the <code class="literal">search()</code> method return?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe4"/><a id="ch07qa1q4"/><p>Q:</p></td><td align="left" valign="top"><p>4. How do you get the actual strings that match the pattern from a <code class="literal">Match</code> object?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe5"/><a id="ch07qa1q5"/><p>Q:</p></td><td align="left" valign="top"><p>5. In the regex created from <code class="literal">r'(\d\d\d)-(\d\d\d-\d\d\d\d)'</code>, what does group <code class="literal">0</code> cover? Group <code class="literal">1</code>? Group <code class="literal">2</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe6"/><a id="ch07qa1q6"/><p>Q:</p></td><td align="left" valign="top"><p>6. Parentheses and periods have specific meanings in regular expression syntax. How would you specify that you want a regex to match actual parentheses and period characters?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe7"/><a id="ch07qa1q7"/><p>Q:</p></td><td align="left" valign="top"><p>7. The <code class="literal">findall()</code> method returns a list of strings or a list of tuples of strings. What makes it return one or the other?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe8"/><a id="ch07qa1q8"/><p>Q:</p></td><td align="left" valign="top"><p>8. What does the <code class="literal">|</code> character signify in regular expressions?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe9"/><a id="ch07qa1q9"/><p>Q:</p></td><td align="left" valign="top"><p>9. What two things does the <code class="literal">?</code> character signify in regular expressions?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe10"/><a id="ch07qa1q10"/><p>Q:</p></td><td align="left" valign="top"><p>10. What is the difference between the <code class="literal">+</code> and <code class="literal">*</code> characters in regular expressions?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe11"/><a id="ch07qa1q11"/><p>Q:</p></td><td align="left" valign="top"><p>11. What is the difference between <code class="literal">{3}</code> and <code class="literal">{3,5}</code> in regular expressions?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe12"/><a id="ch07qa1q12"/><p>Q:</p></td><td align="left" valign="top"><p>12. What do the <code class="literal">\d</code>, <code class="literal">\w</code>, and <code class="literal">\s</code> shorthand character classes signify in regular expressions?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe13"/><a id="ch07qa1q13"/><p>Q:</p></td><td align="left" valign="top"><p>13. What do the <code class="literal">\D</code>, <code class="literal">\W</code>, and <code class="literal">\S</code> shorthand character classes signify in regular expressions?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe14"/><a id="ch07qa1q14"/><p>Q:</p></td><td align="left" valign="top"><p>14. How do you make a regular expression case-insensitive?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe15"/><a id="ch07qa1q15"/><p>Q:</p></td><td align="left" valign="top"><p>15. What does the <code class="literal">.</code> character normally match? What does it match if <code class="literal">re.DOTALL</code> is passed as the second argument to <code class="literal">re.compile()</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe16"/><a id="ch07qa1q16"/><p>Q:</p></td><td align="left" valign="top"><p>16. What is the difference between <code class="literal">.*</code> and <code class="literal">.*?</code>?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe17"/><a id="ch07qa1q17"/><p>Q:</p></td><td align="left" valign="top"><p>17. What is the character class syntax to match all numbers and lowercase letters?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe18"/><a id="ch07qa1q18"/><p>Q:</p></td><td align="left" valign="top"><p>18. If <code class="literal">numRegex = re.compile(r'\d+')</code>, what will <code class="literal">numRegex.sub('X', '12 drummers, 11 pipers, five rings, 3 hens')</code> return?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe19"/><a id="ch07qa1q19"/><p>Q:</p></td><td align="left" valign="top"><p>19. What does passing <code class="literal">re.VERBOSE</code> as the second argument to <code class="literal">re.compile()</code> allow you to do?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe20"/><a id="ch07qa1q20"/><p>Q:</p></td><td align="left" valign="top"><p>20. How would you write a regex that matches a number with commas for every three digits? It must match the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">'42'</code></p></li><li class="listitem"><p><code class="literal">'1,234'</code></p></li><li class="listitem"><p><code class="literal">'6,368,745'</code></p></li></ul></div><p>but not the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">'12,34,567'</code> (which has only two digits between the commas)</p></li><li class="listitem"><p><code class="literal">'1234'</code> (which lacks commas)</p></li></ul></div></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe21"/><a id="ch07qa1q21"/><p>Q:</p></td><td align="left" valign="top"><p>21. How would you write a regex that matches the full name of someone whose last name is Nakamoto? You can assume that the first name that comes before it will always be one word that begins with a capital letter. The regex must match the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">'Satoshi Nakamoto'</code></p></li><li class="listitem"><p><code class="literal">'Alice Nakamoto'</code></p></li><li class="listitem"><p><code class="literal">'RoboCop Nakamoto'</code></p></li></ul></div><p>but not the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">'satoshi Nakamoto'</code> (where the first name is not capitalized)</p></li><li class="listitem"><p><code class="literal">'Mr. Nakamoto'</code> (where the preceding word has a nonletter character)</p></li><li class="listitem"><p><code class="literal">'Nakamoto'</code> (which has no first name)</p></li><li class="listitem"><p><code class="literal">'Satoshi nakamoto'</code> (where Nakamoto is not capitalized)</p></li></ul></div></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe22"/><a id="ch07qa1q22"/><p>Q:</p></td><td align="left" valign="top"><p>22. How would you write a regex that matches a sentence where the first word is either <span class="emphasis"><em>Alice</em></span>, <span class="emphasis"><em>Bob</em></span>, or <span class="emphasis"><em>Carol</em></span>; the second word is either <span class="emphasis"><em>eats</em></span>, <span class="emphasis"><em>pets</em></span>, or <span class="emphasis"><em>throws</em></span>; the third word is <span class="emphasis"><em>apples</em></span>, <span class="emphasis"><em>cats</em></span>, or <span class="emphasis"><em>baseballs</em></span>; and the sentence ends with a period? This regex should be case-insensitive. It must match the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">'Alice eats apples.'</code></p></li><li class="listitem"><p><code class="literal">'Bob pets cats.'</code></p></li><li class="listitem"><p><code class="literal">'Carol throws baseballs.'</code></p></li><li class="listitem"><p><code class="literal">'Alice throws Apples.'</code></p></li><li class="listitem"><p><code class="literal">'BOB EATS CATS.'</code></p></li></ul></div><p>but not the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">'RoboCop eats apples.'</code></p></li><li class="listitem"><p><code class="literal">'ALICE THROWS FOOTBALLS.'</code></p></li><li class="listitem"><p><code class="literal">'Carol eats 7 cats.'</code></p></li></ul></div></td></tr></tbody></table></div></div><div class="sect1" title="Practice Projects"><div class="titlepage"><div><div><h1 class="title"><a id="practice_projects-id00022"/>Practice Projects</h1></div></div></div><p>For practice, write programs to do the following tasks.</p><div class="sect2" title="Strong Password Detection"><div class="titlepage"><div><div><h2 class="title"><a id="strong_password_detection"/>Strong Password Detection</h2></div></div></div><p>Write a function that uses regular expressions to make sure the password string it is passed is strong. A strong password is defined as one that is at least eight characters long, contains both uppercase and lowercase characters, and has at least one digit. You may need to test the string against multiple regex patterns to validate its strength.</p></div><div class="sect2" title="Regex Version of strip()"><div class="titlepage"><div><div><h2 class="title"><a id="regex_version_of_stripleft_parenthesisri"/>Regex Version of strip()</h2></div></div></div><p>Write a function that takes a string and does the same thing as the <code class="literal">strip()</code> string method. If no other arguments are passed other than the string to strip, then whitespace characters will be removed from the beginning and end of the string. Otherwise, the characters specified in the second argument to the function will be removed from the string.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch07fn01" href="#ch07fn01" class="para">1</a>] </sup>Cory Doctorow, “Here’s what ICT should really teach kids: how to do regular expressions,” <span class="emphasis"><em>Guardian</em></span>, December 4, 2012, <span class="emphasis"><em><a class="ulink" href="http://www.theguardian.com/technology/2012/dec/04/ict-teach-kids-regular-expressions/">http://www.theguardian.com/technology/2012/dec/04/ict-teach-kids-regular-expressions/</a>.</em></span></p></div></div></div></body></html>
